<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/jspm/jspm"

    >jspm (v0.16.53)</a>
</h1>
<h4>Registry and format agnostic JavaScript package manager</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm">module jspm</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.Builder">
            function <span class="apidocSignatureSpan">jspm.</span>Builder
            <span class="apidocSignatureSpan">(_config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.Loader">
            function <span class="apidocSignatureSpan">jspm.</span>Loader
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.bundle">
            function <span class="apidocSignatureSpan">jspm.</span>bundle
            <span class="apidocSignatureSpan">(expression, fileName, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.bundleSFX">
            function <span class="apidocSignatureSpan">jspm.</span>bundleSFX
            <span class="apidocSignatureSpan">(expression, fileName, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.dlLoader">
            function <span class="apidocSignatureSpan">jspm.</span>dlLoader
            <span class="apidocSignatureSpan">(transpiler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.import">
            function <span class="apidocSignatureSpan">jspm.</span>import
            <span class="apidocSignatureSpan">(name, parentName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.install">
            function <span class="apidocSignatureSpan">jspm.</span>install
            <span class="apidocSignatureSpan">(name, target, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.normalize">
            function <span class="apidocSignatureSpan">jspm.</span>normalize
            <span class="apidocSignatureSpan">(name, parentName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.promptDefaults">
            function <span class="apidocSignatureSpan">jspm.</span>promptDefaults
            <span class="apidocSignatureSpan">(_useDefaults)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.setPackagePath">
            function <span class="apidocSignatureSpan">jspm.</span>setPackagePath
            <span class="apidocSignatureSpan">(packagePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.unbundle">
            function <span class="apidocSignatureSpan">jspm.</span>unbundle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.uninstall">
            function <span class="apidocSignatureSpan">jspm.</span>uninstall
            <span class="apidocSignatureSpan">(names)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jspm.</span>_eventsCount</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>Builder.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>_events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>common</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>core</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>domain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>global_config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>link</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>package</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>registry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>semver</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>ui</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jspm.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.Builder">module jspm.Builder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.Builder.Builder">
            function <span class="apidocSignatureSpan">jspm.</span>Builder
            <span class="apidocSignatureSpan">(_config)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.Builder.prototype">module jspm.Builder.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.Builder.prototype.buildStatic">
            function <span class="apidocSignatureSpan">jspm.Builder.prototype.</span>buildStatic
            <span class="apidocSignatureSpan">(expressionOrTree, outFile, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.Builder.prototype.bundle">
            function <span class="apidocSignatureSpan">jspm.Builder.prototype.</span>bundle
            <span class="apidocSignatureSpan">(expressionOrTree, outFile, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.bundle">module jspm.bundle</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.bundle.bundle">
            function <span class="apidocSignatureSpan">jspm.</span>bundle
            <span class="apidocSignatureSpan">(moduleExpression, fileName, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.bundle.Builder">
            function <span class="apidocSignatureSpan">jspm.bundle.</span>Builder
            <span class="apidocSignatureSpan">(_config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.bundle.bundleSFX">
            function <span class="apidocSignatureSpan">jspm.bundle.</span>bundleSFX
            <span class="apidocSignatureSpan">(expression, fileName, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.bundle.depCache">
            function <span class="apidocSignatureSpan">jspm.bundle.</span>depCache
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.bundle.unbundle">
            function <span class="apidocSignatureSpan">jspm.bundle.</span>unbundle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.common">module jspm.common</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.common.alphabetize">
            function <span class="apidocSignatureSpan">jspm.common.</span>alphabetize
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.common.cascadeDelete">
            function <span class="apidocSignatureSpan">jspm.common.</span>cascadeDelete
            <span class="apidocSignatureSpan">(dir, stopDir)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.common.dextend">
            function <span class="apidocSignatureSpan">jspm.common.</span>dextend
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.common.dprepend">
            function <span class="apidocSignatureSpan">jspm.common.</span>dprepend
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.common.extend">
            function <span class="apidocSignatureSpan">jspm.common.</span>extend
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.common.fromFileURL">
            function <span class="apidocSignatureSpan">jspm.common.</span>fromFileURL
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.common.getRedirectContents">
            function <span class="apidocSignatureSpan">jspm.common.</span>getRedirectContents
            <span class="apidocSignatureSpan">(format, main)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.common.hasProperties">
            function <span class="apidocSignatureSpan">jspm.common.</span>hasProperties
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.common.readJSON">
            function <span class="apidocSignatureSpan">jspm.common.</span>readJSON
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.common.readJSONSync">
            function <span class="apidocSignatureSpan">jspm.common.</span>readJSONSync
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.common.stringify">
            function <span class="apidocSignatureSpan">jspm.common.</span>stringify
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.common.toFileURL">
            function <span class="apidocSignatureSpan">jspm.common.</span>toFileURL
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.config">module jspm.config</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">jspm.config.</span>loaded</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.config.derivePackageConfig">
            function <span class="apidocSignatureSpan">jspm.config.</span>derivePackageConfig
            <span class="apidocSignatureSpan">(pjson, override)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.config.load">
            function <span class="apidocSignatureSpan">jspm.config.</span>load
            <span class="apidocSignatureSpan">(prompts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.config.loadSync">
            function <span class="apidocSignatureSpan">jspm.config.</span>loadSync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.config.save">
            function <span class="apidocSignatureSpan">jspm.config.</span>save
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.config.</span>loader</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.config.</span>pjson</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jspm.config.</span>HOME</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jspm.config.</span>newLine</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jspm.config.</span>tab</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.core">module jspm.core</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.core.build">
            function <span class="apidocSignatureSpan">jspm.core.</span>build
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.core.cacheClear">
            function <span class="apidocSignatureSpan">jspm.core.</span>cacheClear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.core.checkDlLoader">
            function <span class="apidocSignatureSpan">jspm.core.</span>checkDlLoader
            <span class="apidocSignatureSpan">(transpilerName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.core.dlLoader">
            function <span class="apidocSignatureSpan">jspm.core.</span>dlLoader
            <span class="apidocSignatureSpan">(transpilerName, unminified, edge, latest)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.core.dlTranspiler">
            function <span class="apidocSignatureSpan">jspm.core.</span>dlTranspiler
            <span class="apidocSignatureSpan">(transpilerName, update)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.core.init">
            function <span class="apidocSignatureSpan">jspm.core.</span>init
            <span class="apidocSignatureSpan">(basePath, ask)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.core.run">
            function <span class="apidocSignatureSpan">jspm.core.</span>run
            <span class="apidocSignatureSpan">(moduleName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.core.setMode">
            function <span class="apidocSignatureSpan">jspm.core.</span>setMode
            <span class="apidocSignatureSpan">(modes)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.global_config">module jspm.global_config</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.global_config.save">
            function <span class="apidocSignatureSpan">jspm.global_config.</span>save
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.global_config.set">
            function <span class="apidocSignatureSpan">jspm.global_config.</span>set
            <span class="apidocSignatureSpan">(name, val)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.global_config.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.global_config.</span>registries</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.install">module jspm.install</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.install.install">
            function <span class="apidocSignatureSpan">jspm.</span>install
            <span class="apidocSignatureSpan">(targets, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.install.clean">
            function <span class="apidocSignatureSpan">jspm.install.</span>clean
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.install.resolveOnly">
            function <span class="apidocSignatureSpan">jspm.install.</span>resolveOnly
            <span class="apidocSignatureSpan">(pkg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.install.showInstallGraph">
            function <span class="apidocSignatureSpan">jspm.install.</span>showInstallGraph
            <span class="apidocSignatureSpan">(pkg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.install.showVersions">
            function <span class="apidocSignatureSpan">jspm.install.</span>showVersions
            <span class="apidocSignatureSpan">(forks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.install.uninstall">
            function <span class="apidocSignatureSpan">jspm.install.</span>uninstall
            <span class="apidocSignatureSpan">(names)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.link">module jspm.link</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.link.link">
            function <span class="apidocSignatureSpan">jspm.</span>link
            <span class="apidocSignatureSpan">(name, dir, force)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.link.lookup">
            function <span class="apidocSignatureSpan">jspm.link.</span>lookup
            <span class="apidocSignatureSpan">(pkg, edge)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.link.symlink">
            function <span class="apidocSignatureSpan">jspm.link.</span>symlink
            <span class="apidocSignatureSpan">(pkg, downloadDeps)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.package">module jspm.package</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package.createMain">
            function <span class="apidocSignatureSpan">jspm.package.</span>createMain
            <span class="apidocSignatureSpan">(pkg, pjson, downloadDir)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package.derivePackageConfig">
            function <span class="apidocSignatureSpan">jspm.package.</span>derivePackageConfig
            <span class="apidocSignatureSpan">(pkg, pjson, override)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package.download">
            function <span class="apidocSignatureSpan">jspm.package.</span>download
            <span class="apidocSignatureSpan">(pkg, options, installDeps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package.getVersionMatch">
            function <span class="apidocSignatureSpan">jspm.package.</span>getVersionMatch
            <span class="apidocSignatureSpan">(pkgVersion, versions, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package.inject">
            function <span class="apidocSignatureSpan">jspm.package.</span>inject
            <span class="apidocSignatureSpan">(pkg, depLoad)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package.locate">
            function <span class="apidocSignatureSpan">jspm.package.</span>locate
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package.lookup">
            function <span class="apidocSignatureSpan">jspm.package.</span>lookup
            <span class="apidocSignatureSpan">(pkg, edge)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package.processDeps">
            function <span class="apidocSignatureSpan">jspm.package.</span>processDeps
            <span class="apidocSignatureSpan">(deps, registry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package.processPackage">
            function <span class="apidocSignatureSpan">jspm.package.</span>processPackage
            <span class="apidocSignatureSpan">(pkg, dir, pjson, postload, isCDN)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.package.</span>registryCache</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.registry">module jspm.registry</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.registry.configure">
            function <span class="apidocSignatureSpan">jspm.registry.</span>configure
            <span class="apidocSignatureSpan">(registry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.registry.create">
            function <span class="apidocSignatureSpan">jspm.registry.</span>create
            <span class="apidocSignatureSpan">(name, handler, override)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.registry.load">
            function <span class="apidocSignatureSpan">jspm.registry.</span>load
            <span class="apidocSignatureSpan">(registry)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.semver">module jspm.semver</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.semver.compare">
            function <span class="apidocSignatureSpan">jspm.semver.</span>compare
            <span class="apidocSignatureSpan">(v1, v2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.semver.match">
            function <span class="apidocSignatureSpan">jspm.semver.</span>match
            <span class="apidocSignatureSpan">(range, version)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.semver.matchUnstable">
            function <span class="apidocSignatureSpan">jspm.semver.</span>matchUnstable
            <span class="apidocSignatureSpan">(range, version)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.semver.</span>semverRegEx</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.ui">module jspm.ui</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.ui.confirm">
            function <span class="apidocSignatureSpan">jspm.ui.</span>confirm
            <span class="apidocSignatureSpan">(msg, def)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.ui.input">
            function <span class="apidocSignatureSpan">jspm.ui.</span>input
            <span class="apidocSignatureSpan">(msg, def, disableOutput, queue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.ui.log">
            function <span class="apidocSignatureSpan">jspm.ui.</span>log
            <span class="apidocSignatureSpan">(type, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.ui.setLogLevel">
            function <span class="apidocSignatureSpan">jspm.ui.</span>setLogLevel
            <span class="apidocSignatureSpan">(level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.ui.setResolver">
            function <span class="apidocSignatureSpan">jspm.ui.</span>setResolver
            <span class="apidocSignatureSpan">(resolver)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.ui.useDefaults">
            function <span class="apidocSignatureSpan">jspm.ui.</span>useDefaults
            <span class="apidocSignatureSpan">(_useDefaults)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jspm.ui.</span>logLevel</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.ui.</span>format</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm" id="apidoc.module.jspm">module jspm</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.Builder" id="apidoc.element.jspm.Builder">
        function <span class="apidocSignatureSpan">jspm.</span>Builder
        <span class="apidocSignatureSpan">(_config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Builder(_config) {
  config.loadSync();
  SystemJSBuilder.call(this, toFileURL(config.pjson.baseURL));

  var cfg = config.loader.getConfig();

  if (cfg.depCache)
    delete cfg.depCache;
  if (cfg.bundles)
    delete cfg.bundles;
  if (cfg.baseURL)
    delete cfg.baseURL;

  this.config(cfg, true);

  if (typeof _config == &#x27;object&#x27;)
    this.config(_config, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.Loader" id="apidoc.element.jspm.Loader">
        function <span class="apidocSignatureSpan">jspm.</span>Loader
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Loader = function () {
  config.loadSync();

  var cfg = config.loader.getConfig();
  cfg.baseURL = toFileURL(config.pjson.baseURL);

  var loader = new SystemJSLoader();
  loader.config(cfg);

  return loader;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.bundle" id="apidoc.element.jspm.bundle">
        function <span class="apidocSignatureSpan">jspm.</span>bundle
        <span class="apidocSignatureSpan">(expression, fileName, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bundle = function (expression, fileName, options) {
  return bundle.bundle(expression, fileName, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.then(function() {
  ui.log(&#x27;info&#x27;, &#x27;Building the bundle tree for `&#x27; + moduleExpression + &#x27;`...&#x27;);

  return systemBuilder.trace(moduleExpression);
})
.then(function(buildTree) {
  logTree(buildTree);
  return systemBuilder.<span class="apidocCodeKeywordSpan">bundle</span>(buildTree, fileName, opts);
})
.then(function(output) {
  if (opts.injectConfig)
    ui.log(&#x27;ok&#x27;, &#x27;`&#x27; + output.bundleName + &#x27;` added to config bundles.&#x27;);

  logBuild(path.relative(process.cwd(), fileName), opts);
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.bundleSFX" id="apidoc.element.jspm.bundleSFX">
        function <span class="apidocSignatureSpan">jspm.</span>bundleSFX
        <span class="apidocSignatureSpan">(expression, fileName, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bundleSFX = function (expression, fileName, options) {
  return bundle.bundleSFX(expression, fileName, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.dlLoader" id="apidoc.element.jspm.dlLoader">
        function <span class="apidocSignatureSpan">jspm.</span>dlLoader
        <span class="apidocSignatureSpan">(transpiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dlLoader = function (transpiler) {
  return core.checkDlLoader(transpiler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .catch(function(err) {
if (err.code === &#x27;ENOENT&#x27;)
  return &#x27;&#x27;;
throw err;
  })
  .then(function(cacheVersions) {
if (cacheVersions.toString() !== systemVersion)
  return exports.<span class="apidocCodeKeywordSpan">dlLoader</span>(transpilerName);

// even if version file is fresh, still check files exist
return asp(fs.readdir)(config.pjson.packages)
.catch(function(err) {
  if (err.code === &#x27;ENOENT&#x27;)
    return [];
  throw err;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.import" id="apidoc.element.jspm.import">
        function <span class="apidocSignatureSpan">jspm.</span>import
        <span class="apidocSignatureSpan">(name, parentName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">import = function (name, parentName) {
  apiLoader = apiLoader || new API.Loader();
  return apiLoader.import(name, parentName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return config.load()
  .then(function() {
    var cfg = config.loader.getConfig();
    delete cfg.bundles;
    cfg.baseURL = toFileURL(config.pjson.baseURL);
    System.config(cfg);

    return System.<span class="apidocCodeKeywordSpan">import</span>(moduleName);
  })
  .catch(function(e) {
    ui.log(&#x27;err&#x27;, e.stack || e);
  });
};

exports.build = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.install" id="apidoc.element.jspm.install">
        function <span class="apidocSignatureSpan">jspm.</span>install
        <span class="apidocSignatureSpan">(name, target, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">install = function (name, target, options) {
  return install.install(name, target, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (target)
      installObj[&#x27;core-js&#x27;] = target.exactName;
    else
      installObj[&#x27;core-js&#x27;] = tPackages[&#x27;core-js&#x27;];
  }

  // just do a quick install which checks basic existence
  return install.<span class="apidocCodeKeywordSpan">install</span>(installObj, { quick: !update, dev: true, summary: false });
})
.then(function() {
  if (config.loader.transpiler !== transpilerName) {
    config.loader.transpiler = transpilerName;

    if (transpilerName !== &#x27;none&#x27;)
      ui.log(&#x27;ok&#x27;, &#x27;ES6 transpiler set to %&#x27; + transpilerName + &#x27;%.&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.normalize" id="apidoc.element.jspm.normalize">
        function <span class="apidocSignatureSpan">jspm.</span>normalize
        <span class="apidocSignatureSpan">(name, parentName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalize = function (name, parentName) {
  apiLoader = apiLoader || new API.Loader();
  return apiLoader.normalize(name, parentName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.promptDefaults" id="apidoc.element.jspm.promptDefaults">
        function <span class="apidocSignatureSpan">jspm.</span>promptDefaults
        <span class="apidocSignatureSpan">(_useDefaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">promptDefaults = function (_useDefaults) {
  ui.useDefaults(_useDefaults);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.setPackagePath" id="apidoc.element.jspm.setPackagePath">
        function <span class="apidocSignatureSpan">jspm.</span>setPackagePath
        <span class="apidocSignatureSpan">(packagePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setPackagePath = function (packagePath) {
  if (config.loaded &#x26;&#x26; process.env.jspmConfigPath !== path.resolve(packagePath, &#x27;package.json&#x27;))
    throw new Error(&#x27;Configuration has already been loaded. Call setPackagePath before using other APIs.&#x27;);
  process.env.jspmConfigPath = path.resolve(packagePath, &#x27;package.json&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.unbundle" id="apidoc.element.jspm.unbundle">
        function <span class="apidocSignatureSpan">jspm.</span>unbundle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbundle = function () {
  return bundle.unbundle();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.uninstall" id="apidoc.element.jspm.uninstall">
        function <span class="apidocSignatureSpan">jspm.</span>uninstall
        <span class="apidocSignatureSpan">(names)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uninstall = function (names) {
  return install.uninstall(names);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.Builder" id="apidoc.module.jspm.Builder">module jspm.Builder</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.Builder.Builder" id="apidoc.element.jspm.Builder.Builder">
        function <span class="apidocSignatureSpan">jspm.</span>Builder
        <span class="apidocSignatureSpan">(_config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Builder(_config) {
  config.loadSync();
  SystemJSBuilder.call(this, toFileURL(config.pjson.baseURL));

  var cfg = config.loader.getConfig();

  if (cfg.depCache)
    delete cfg.depCache;
  if (cfg.bundles)
    delete cfg.bundles;
  if (cfg.baseURL)
    delete cfg.baseURL;

  this.config(cfg, true);

  if (typeof _config == &#x27;object&#x27;)
    this.config(_config, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.Builder.prototype" id="apidoc.module.jspm.Builder.prototype">module jspm.Builder.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.Builder.prototype.buildStatic" id="apidoc.element.jspm.Builder.prototype.buildStatic">
        function <span class="apidocSignatureSpan">jspm.Builder.prototype.</span>buildStatic
        <span class="apidocSignatureSpan">(expressionOrTree, outFile, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildStatic = function (expressionOrTree, outFile, opts) {
  if (outFile &#x26;&#x26; typeof outFile === &#x27;object&#x27;) {
    opts = outFile;
    outFile = undefined;
  }

  opts = opts || {};

  if (outFile)
    opts.outFile = outFile;

  if (!(&#x27;format&#x27; in opts))
    opts.format = &#x27;global&#x27;;

  if (!(&#x27;lowResSourceMaps&#x27; in opts))
    opts.lowResSourceMaps = true;

  return SystemJSBuilder.prototype.buildStatic.call(this, expressionOrTree, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return removeExistingSourceMap(fileName);
})
.then(function() {
  ui.log(&#x27;info&#x27;, &#x27;Building the single-file sfx bundle for `&#x27; + expression + &#x27;`...&#x27;);

  opts.format = opts.format || &#x27;global&#x27;;

  return systemBuilder.<span class="apidocCodeKeywordSpan">buildStatic</span>(expression, fileName, opts);
})
.then(function() {
  logBuild(path.relative(process.cwd(), fileName), opts);
})
.catch(function(e) {
  // catch sfx globals error to give a better error message
  if (e.toString().indexOf(&#x27;globalDeps option&#x27;) != -1) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.Builder.prototype.bundle" id="apidoc.element.jspm.Builder.prototype.bundle">
        function <span class="apidocSignatureSpan">jspm.Builder.prototype.</span>bundle
        <span class="apidocSignatureSpan">(expressionOrTree, outFile, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bundle = function (expressionOrTree, outFile, opts) {
  if (outFile &#x26;&#x26; typeof outFile === &#x27;object&#x27;) {
    opts = outFile;
    outFile = undefined;
  }

  opts = opts || {};

  if (outFile)
    opts.outFile = outFile;

  if (!(&#x27;normalize&#x27; in opts))
    opts.normalize = true;

  if (!(&#x27;lowResSourceMaps&#x27; in opts))
    opts.lowResSourceMaps = true;

  var self = this;

  return SystemJSBuilder.prototype.bundle.call(this, expressionOrTree, opts)
  .then(function(output) {

    // Add the bundle to config if the inject flag was given
    if (opts.injectConfig &#x26;&#x26; opts.outFile) {
      // NB deprecate
      output.bundleName = output.bundleName || self.getCanonicalName(toFileURL(path.resolve(opts.outFile)));
      var bundleName = output.bundleName;

      if (!config.loader.bundles)
        config.loader.bundles = {};

      config.loader.bundles[bundleName] = output.modules;
      return config.save()
      .then(function() {
        return output;
      });
    }

    return output;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.then(function() {
  ui.log(&#x27;info&#x27;, &#x27;Building the bundle tree for `&#x27; + moduleExpression + &#x27;`...&#x27;);

  return systemBuilder.trace(moduleExpression);
})
.then(function(buildTree) {
  logTree(buildTree);
  return systemBuilder.<span class="apidocCodeKeywordSpan">bundle</span>(buildTree, fileName, opts);
})
.then(function(output) {
  if (opts.injectConfig)
    ui.log(&#x27;ok&#x27;, &#x27;`&#x27; + output.bundleName + &#x27;` added to config bundles.&#x27;);

  logBuild(path.relative(process.cwd(), fileName), opts);
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.bundle" id="apidoc.module.jspm.bundle">module jspm.bundle</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.bundle.bundle" id="apidoc.element.jspm.bundle.bundle">
        function <span class="apidocSignatureSpan">jspm.</span>bundle
        <span class="apidocSignatureSpan">(moduleExpression, fileName, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bundle = function (moduleExpression, fileName, opts) {

  var systemBuilder = new Builder();

  opts = opts || {};

  opts.normalize = true;

  fileName = fileName || path.resolve(config.pjson.baseURL, &#x27;build.js&#x27;);

  return Promise.resolve()
  .then(function() {

    if (!opts.sourceMaps)
      return removeExistingSourceMap(fileName);
  })
  .then(function() {
    ui.log(&#x27;info&#x27;, &#x27;Building the bundle tree for `&#x27; + moduleExpression + &#x27;`...&#x27;);

    return systemBuilder.trace(moduleExpression);
  })
  .then(function(buildTree) {
    logTree(buildTree);
    return systemBuilder.bundle(buildTree, fileName, opts);
  })
  .then(function(output) {
    if (opts.injectConfig)
      ui.log(&#x27;ok&#x27;, &#x27;`&#x27; + output.bundleName + &#x27;` added to config bundles.&#x27;);

    logBuild(path.relative(process.cwd(), fileName), opts);
  })
  .catch(function(e) {
    ui.log(&#x27;err&#x27;, e.stack || e);
    throw e;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.then(function() {
  ui.log(&#x27;info&#x27;, &#x27;Building the bundle tree for `&#x27; + moduleExpression + &#x27;`...&#x27;);

  return systemBuilder.trace(moduleExpression);
})
.then(function(buildTree) {
  logTree(buildTree);
  return systemBuilder.<span class="apidocCodeKeywordSpan">bundle</span>(buildTree, fileName, opts);
})
.then(function(output) {
  if (opts.injectConfig)
    ui.log(&#x27;ok&#x27;, &#x27;`&#x27; + output.bundleName + &#x27;` added to config bundles.&#x27;);

  logBuild(path.relative(process.cwd(), fileName), opts);
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.bundle.Builder" id="apidoc.element.jspm.bundle.Builder">
        function <span class="apidocSignatureSpan">jspm.bundle.</span>Builder
        <span class="apidocSignatureSpan">(_config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Builder(_config) {
  config.loadSync();
  SystemJSBuilder.call(this, toFileURL(config.pjson.baseURL));

  var cfg = config.loader.getConfig();

  if (cfg.depCache)
    delete cfg.depCache;
  if (cfg.bundles)
    delete cfg.bundles;
  if (cfg.baseURL)
    delete cfg.baseURL;

  this.config(cfg, true);

  if (typeof _config == &#x27;object&#x27;)
    this.config(_config, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.bundle.bundleSFX" id="apidoc.element.jspm.bundle.bundleSFX">
        function <span class="apidocSignatureSpan">jspm.bundle.</span>bundleSFX
        <span class="apidocSignatureSpan">(expression, fileName, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bundleSFX = function (expression, fileName, opts) {
  var systemBuilder = new Builder();

  opts = opts || {};

  fileName = fileName || path.resolve(config.pjson.baseURL, &#x27;build.js&#x27;);

  return Promise.resolve()
  .then(function() {
    if (!opts.sourceMaps)
      return removeExistingSourceMap(fileName);
  })
  .then(function() {
    ui.log(&#x27;info&#x27;, &#x27;Building the single-file sfx bundle for `&#x27; + expression + &#x27;`...&#x27;);

    opts.format = opts.format || &#x27;global&#x27;;

    return systemBuilder.buildStatic(expression, fileName, opts);
  })
  .then(function() {
    logBuild(path.relative(process.cwd(), fileName), opts);
  })
  .catch(function(e) {
    // catch sfx globals error to give a better error message
    if (e.toString().indexOf(&#x27;globalDeps option&#x27;) != -1) {
      var module = e.toString().match(/dependency &#x22;([^&#x22;]+)&#x22;/);
      ui.log(&#x27;err&#x27;, &#x27;SFX exclusion &#x22;&#x27; + module[1] + &#x27;&#x22; needs a reference.\nEither output an SFX module format like %--format amd
% or map the module to an environment global via %--globals &#x22;{\&#x27;test.js\&#x27;: \&#x27;test\&#x27;}&#x22;%.&#x27;);
      throw &#x27;SFX Bundle input error&#x27;;
    }

    ui.log(&#x27;err&#x27;, e.stack || e);
    throw e;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.bundle.depCache" id="apidoc.element.jspm.bundle.depCache">
        function <span class="apidocSignatureSpan">jspm.bundle.</span>depCache
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">depCache = function (expression) {
  var systemBuilder = new Builder();

  expression = expression || config.loader.main;

  ui.log(&#x27;info&#x27;, &#x27;Injecting the traced dependency tree for `&#x27; + expression + &#x27;`...&#x27;);

  return systemBuilder.trace(expression)
  .then(function(tree) {
    logTree(tree);
    var depCache = config.loader.depCache || {};
    extend(depCache, systemBuilder.getDepCache(tree));
    config.loader.depCache = depCache;
  })
  .then(config.save)
  .then(function() {
    ui.log(&#x27;ok&#x27;, &#x27;Dependency tree injected&#x27;);
  })
  .catch(function(e) {
    ui.log(&#x27;err&#x27;, e.stack || e);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.bundle.unbundle" id="apidoc.element.jspm.bundle.unbundle">
        function <span class="apidocSignatureSpan">jspm.bundle.</span>unbundle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbundle = function () {
  return config.load()
  .then(function() {
    config.loader.bundles = {};
    config.loader.depCache = {};
    return config.save();
  })
  .then(function() {
    ui.log(&#x27;ok&#x27;, &#x27;Bundle configuration removed.&#x27;);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.common" id="apidoc.module.jspm.common">module jspm.common</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.common.alphabetize" id="apidoc.element.jspm.common.alphabetize">
        function <span class="apidocSignatureSpan">jspm.common.</span>alphabetize
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alphabetize = function (obj) {
  var newObj = {};
  Object.keys(obj).sort().forEach(function(p) {
    newObj[p] = obj[p];
  });
  return newObj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.common.cascadeDelete" id="apidoc.element.jspm.common.cascadeDelete">
        function <span class="apidocSignatureSpan">jspm.common.</span>cascadeDelete
        <span class="apidocSignatureSpan">(dir, stopDir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cascadeDelete(dir, stopDir) {
  if (dir &#x26;&#x26; dir !== stopDir) {
    return asp(fs.rmdir)(dir)
    .catch(function(err) {
      // just continue if directory does not exist
      if (err.code !== &#x27;ENOENT&#x27;)
        throw err;
    })
    .then(function() {
      return cascadeDelete(path.dirname(dir), stopDir);
    })
    .catch(function(err) {
      // gracefully stop at first non-empty directory
      if (err.code !== &#x27;ENOTEMPTY&#x27;)
        throw err;
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.common.dextend" id="apidoc.element.jspm.common.dextend">
        function <span class="apidocSignatureSpan">jspm.common.</span>dextend
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dextend(a, b) {
  for (var p in b) {
    if (!b.hasOwnProperty(p))
      continue;
    var val = b[p];
    if (typeof val === &#x27;object&#x27;)
      dextend(a[p] = typeof a[p] === &#x27;object&#x27; ? a[p] : {}, val);
    else
      a[p] = val;
  }
  return a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.common.dprepend" id="apidoc.element.jspm.common.dprepend">
        function <span class="apidocSignatureSpan">jspm.common.</span>dprepend
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dprepend(a, b) {
  for (var p in b) {
    if (!b.hasOwnProperty(p))
      continue;

    var val = b[p];
    if (typeof val === &#x27;object&#x27;)
      dprepend(a[p] = typeof a[p] === &#x27;object&#x27; ? a[p] : {}, val);
    else if (!(p in a))
      a[p] = val;
  }
  return a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.common.extend" id="apidoc.element.jspm.common.extend">
        function <span class="apidocSignatureSpan">jspm.common.</span>extend
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (a, b) {
  for (var p in b) {
    if (b.hasOwnProperty(p)) {
      a[p] = b[p];
    }
  }
  return a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.common.fromFileURL" id="apidoc.element.jspm.common.fromFileURL">
        function <span class="apidocSignatureSpan">jspm.common.</span>fromFileURL
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromFileURL(path) {
  return path.substr(process.platform.match(/^win/) ? 8 : 7).replace(path.sep, &#x27;/&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.common.getRedirectContents" id="apidoc.element.jspm.common.getRedirectContents">
        function <span class="apidocSignatureSpan">jspm.common.</span>getRedirectContents
        <span class="apidocSignatureSpan">(format, main)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRedirectContents = function (format, main) {
  if (format === &#x27;es6&#x27; || format === &#x27;esm&#x27;)
    return &#x27;export * from &#x22;&#x27; + main + &#x27;&#x22;;\nexport {default} from &#x22;&#x27; + main + &#x27;&#x22;;&#x27;;

  else if (format === &#x27;cjs&#x27; || format === &#x27;global&#x27;)
    return &#x27;module.exports = require(&#x22;&#x27; + main + &#x27;&#x22;);&#x27;;

  else if (format === &#x27;amd&#x27;)
    return &#x27;define([&#x22;&#x27; + main + &#x27;&#x22;], function(main) {\n  return main;\n});&#x27;;

  else if (format === &#x27;register&#x27;)
    return &#x27;System.register([&#x22;&#x27; + main + &#x27;&#x22;], &#x27; +
      &#x27;function($__export) {\n  return {  setters: [function(m) { for (var p in m) $__export(p, m[p]); }],  execute: function() {}  };\n});&#x27;;

  else
    throw &#x27;Unknown module format &#x27; + format + &#x27;.&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.common.hasProperties" id="apidoc.element.jspm.common.hasProperties">
        function <span class="apidocSignatureSpan">jspm.common.</span>hasProperties
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasProperties = function (obj) {
  for (var p in obj) {
    if (obj.hasOwnProperty(p))
      return true;
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.common.readJSON" id="apidoc.element.jspm.common.readJSON">
        function <span class="apidocSignatureSpan">jspm.common.</span>readJSON
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readJSON = function (file) {
  return asp(fs.readFile)(file)
  .then(function(pjson) {
    pjson = pjson.toString();
    // remove any byte order mark
    if (pjson.startsWith(&#x27;\uFEFF&#x27;))
      pjson = pjson.substr(1);
    try {
      return JSON.parse(pjson);
    }
    catch(e) {
      throw &#x27;Error parsing package.json file &#x27; + file;
    }
  }, function(err) {
    if (err.code === &#x27;ENOENT&#x27;)
      return {};
    throw err;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.common.readJSONSync" id="apidoc.element.jspm.common.readJSONSync">
        function <span class="apidocSignatureSpan">jspm.common.</span>readJSONSync
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readJSONSync = function (file) {
  var pjson;
  try {
    pjson = fs.readFileSync(file).toString();
  }
  catch(e) {
    if (e.code === &#x27;ENOENT&#x27;)
      pjson = &#x27;{}&#x27;;
    else
      throw e;
  }
  if (pjson.startsWith(&#x27;\uFEFF&#x27;))
    pjson = pjson.substr(1);
  try {
    return JSON.parse(pjson);
  }
  catch(e) {
    throw &#x27;Error parsing package.json file &#x27; + file;
  }
  return pjson;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.common.stringify" id="apidoc.element.jspm.common.stringify">
        function <span class="apidocSignatureSpan">jspm.common.</span>stringify
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringify = function (subject) {
  return JSON.stringify(subject, null, tab).replace(/\n/g, newLine);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x27;function($__export) {\n  return {  setters: [function(m) { for (var p in m) $__export(p, m[p]); }],  execute: function
() {}  };\n});&#x27;;

else
  throw &#x27;Unknown module format &#x27; + format + &#x27;.&#x27;;
};

exports.stringify = function (subject) {
return JSON.<span class="apidocCodeKeywordSpan">stringify</span>(subject, null, tab).replace(/\n/g, newLine);
};

/* Recursively remove directory, all those above it, if they are empty.
 * Takes optional `stopDir` to terminate at. */
function cascadeDelete(dir, stopDir) {
if (dir &#x26;&#x26; dir !== stopDir) {
  return asp(fs.rmdir)(dir)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.common.toFileURL" id="apidoc.element.jspm.common.toFileURL">
        function <span class="apidocSignatureSpan">jspm.common.</span>toFileURL
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toFileURL(path) {
  return &#x27;file://&#x27; + (process.platform.match(/^win/) ? &#x27;/&#x27; : &#x27;&#x27;) + path.replace(/\\/g, &#x27;/&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.config" id="apidoc.module.jspm.config">module jspm.config</a></h1>




    <h2>
        <a href="#apidoc.element.jspm.config.derivePackageConfig" id="apidoc.element.jspm.config.derivePackageConfig">
        function <span class="apidocSignatureSpan">jspm.config.</span>derivePackageConfig
        <span class="apidocSignatureSpan">(pjson, override)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">derivePackageConfig = function (pjson, override) {
  var dpjson = extend({}, pjson);

  // first derive the override
  if (override || pjson.jspm)
    dpjson.jspm = extend({}, pjson.jspm || {});

  if (override)
    extend(dpjson.jspm, override);

  // then apply the override
  if (override || pjson.jspm)
    extend(dpjson, dpjson.jspm);

  return dpjson;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!registry)
  throw &#x27;Package registry not specified.&#x27;;
if (!version)
  throw &#x27;Package version not specified.&#x27;;

pkg = new PackageName(registry + &#x27;:&#x27; + packageName + &#x27;@&#x27; + version);

return package.<span class="apidocCodeKeywordSpan">derivePackageConfig</span>(pkg, _pjson);
  })
  .then(function(_pjson) {
pjson = _pjson;

linkDir = path.resolve(config.HOME, &#x27;.jspm&#x27;, &#x27;linked&#x27;, pkg.registry, pkg.exactPackage);
try {
  if (fs.existsSync(linkDir)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.config.load" id="apidoc.element.jspm.config.load">
        function <span class="apidocSignatureSpan">jspm.config.</span>load
        <span class="apidocSignatureSpan">(prompts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (prompts) {
  if (loadPromise)
    return loadPromise;

  return (loadPromise = Promise.resolve()
  .then(function() {

    if (process.env.globalJspm === &#x27;true&#x27;)
      ui.log(&#x27;warn&#x27;, &#x27;Running jspm globally, it is advisable to locally install jspm via %npm install jspm --save-dev%.&#x27;);

    if (!process.env.jspmConfigPath)
      return ui.confirm(&#x27;Package.json file does not exist, create it?&#x27;, true)
      .then(function(create) {
        if (!create)
          throw &#x27;Operation aborted.&#x27;;
      });
  })
  .then(function() {
    config.pjsonPath = process.env.jspmConfigPath || path.resolve(process.cwd(), &#x27;package.json&#x27;);

    config.pjson = new PackageConfig(config.pjsonPath);
    return config.pjson.read(prompts);
  })
  .then(function(_prompts) {
    // package.json can indicate if we need to run config prompts for a new package
    prompts = prompts || _prompts;

    if (fs.existsSync(config.pjson.configFile))
      return;

    return ui.confirm(&#x27;Configuration file %&#x27; + path.relative(process.cwd(), config.pjson.configFile) + &#x27;% doesn\&#x27;t exist, create
 it?&#x27;, true)
    .then(function(create) {
      if (!create)
        throw &#x27;Operation aborted.&#x27;;

      // ensure config folder exists
      return asp(mkdirp)(path.dirname(config.pjson.configFile));
    });
  })
  .then(function() {
    config.loader = new LoaderConfig(config.pjson.configFile);
    return config.loader.read(prompts);
  })
  .then(function() {
    return readJSON(path.resolve(config.pjson.packages, &#x27;.dependencies.json&#x27;));
  })
  .then(function(depsJSON) {
    config.deps = setSerializedDeps(depsJSON);
    config.loaded = true;
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.catch(function(e) {
  ui.log(&#x27;err&#x27;, e.stack || e);
  throw e;
});
};

exports.unbundle = function() {
return config.<span class="apidocCodeKeywordSpan">load</span>()
.then(function() {
  config.loader.bundles = {};
  config.loader.depCache = {};
  return config.save();
})
.then(function() {
  ui.log(&#x27;ok&#x27;, &#x27;Bundle configuration removed.&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.config.loadSync" id="apidoc.element.jspm.config.loadSync">
        function <span class="apidocSignatureSpan">jspm.config.</span>loadSync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadSync = function () {
  if (config.loaded)
    return;
  if (loadPromise)
    throw &#x27;Configuration file is already loading.&#x27;;
  config.pjsonPath = process.env.jspmConfigPath || path.resolve(process.cwd(), &#x27;package.json&#x27;);
  config.pjson = new PackageConfig(config.pjsonPath);
  config.pjson.read(false, true);

  if (!fs.existsSync(config.pjson.configFile))
    throw &#x27;No project configuration file not found. Looking for: &#x27; + config.pjson.configFile;

  config.loader = new LoaderConfig(config.pjson.configFile);
  config.loader.read(false, true);

  var depsJSON;
  try {
    depsJSON = JSON.parse(fs.readFileSync(path.resolve(config.pjson.packages, &#x27;.dependencies.json&#x27;)));
  }
  catch(e) {
    if (e.code == &#x27;ENOENT&#x27;)
      depsJSON = {};
    else
      throw e;
  }

  config.deps = setSerializedDeps(depsJSON);

  config.loaded = true;
  loadPromise = Promise.resolve();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var extend = require(&#x27;./common&#x27;).extend;
var alphabetize = require(&#x27;./common&#x27;).alphabetize;
var toFileURL = require(&#x27;./common&#x27;).toFileURL;

// jspm version of builder ignores config, baseURL arguments
// just allows cfg object
function Builder(_config) {
config.<span class="apidocCodeKeywordSpan">loadSync</span>();
SystemJSBuilder.call(this, toFileURL(config.pjson.baseURL));

var cfg = config.loader.getConfig();

if (cfg.depCache)
  delete cfg.depCache;
if (cfg.bundles)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.config.save" id="apidoc.element.jspm.config.save">
        function <span class="apidocSignatureSpan">jspm.config.</span>save
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">save = function () {
  if (savePromise)
    return savePromise.then(exports.save);

  return Promise.resolve()
  .then(function() {
    return config.loader.write();
  })
  .then(function() {
    return config.pjson.write();
  })
  .then(function() {
    return asp(mkdirp)(config.pjson.packages);
  })
  .then(function() {
    return asp(fs.writeFile)(path.resolve(config.pjson.packages, &#x27;.dependencies.json&#x27;), JSON.stringify(getSerializedDeps(config.
deps), null, 2));
  })
  .then(function() {
    savePromise = undefined;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    output.bundleName = output.bundleName || self.getCanonicalName(toFileURL(path.resolve(opts.outFile)));
    var bundleName = output.bundleName;

    if (!config.loader.bundles)
      config.loader.bundles = {};

    config.loader.bundles[bundleName] = output.modules;
    return config.<span class="apidocCodeKeywordSpan">save</span>()
    .then(function() {
      return output;
    });
  }

  return output;
});
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.core" id="apidoc.module.jspm.core">module jspm.core</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.core.build" id="apidoc.element.jspm.core.build">
        function <span class="apidocSignatureSpan">jspm.core.</span>build
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">build = function () {
  var saveConfig = false;

  return config.load()
  .then(function() {
    if (config.pjson.buildConfig.transpileES6 === undefined) {
      saveConfig = true;
      return ui.confirm(&#x27;Transpile ES6?&#x27;, true);
    }
  })
  .then(function(doTranspile) {
    if (doTranspile)
      config.pjson.buildConfig.transpileES6 = true;

    if (!config.pjson.buildConfig || config.pjson.buildConfig.minify === undefined) {
      saveConfig = true;
      return ui.confirm(&#x27;Minify?&#x27;, true);
    }
  })
  .then(function(doMinify) {
    if (doMinify)
      config.pjson.buildConfig.minify = true;

    if (saveConfig)
      return config.save();
  })
  .then(function() {
    return asp(rimraf)(config.pjson.dist);
  })
  .then(function() {
    return asp(ncp)(config.pjson.lib, config.pjson.dist);
  })
  .then(function() {
    return build.compileDir(config.pjson.dist, {
      format: config.pjson.format,
      map: config.pjson.map,
      transpile: config.pjson.buildConfig.transpileES6,
      minify: config.pjson.buildConfig.minify,
      removeJSExtensions: config.pjson.useJSExtensions
    });
  })
  .then(function(compileErrors) {
    if (compileErrors)
      ui.log(&#x27;warn&#x27;, &#x27;Compile Errors:\n&#x27; + compileErrors);
    else
      ui.log(&#x27;ok&#x27;, &#x27;Build Completed&#x27;);
  }, function(err) {
    ui.log(&#x27;err&#x27;, err.stack || err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

.then(function() {
  // now that we have the derived pjson, do the registry build
  if (endpoint.build)
    return Promise.resolve()
    .then(function() {
      curDeps = pjson.dependencies &#x26;&#x26; Object.keys(pjson.dependencies) || [];
      return endpoint.<span class="apidocCodeKeywordSpan">build</span>(pjson, dir);
    })
    .catch(function() {
      throw &#x27;Error building package `&#x27; + pkg.name + &#x27;`.&#x27;;
    });
})

// apply build operations from the package.json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.core.cacheClear" id="apidoc.element.jspm.core.cacheClear">
        function <span class="apidocSignatureSpan">jspm.core.</span>cacheClear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cacheClear = function () {
  var jspmDir = path.resolve(config.HOME, &#x27;.jspm&#x27;),
      packagesCacheDir = path.join(jspmDir, &#x27;packages&#x27;),
      loaderCacheDir = path.join(jspmDir, &#x27;loader-files&#x27;),
      files, filesLength, fileName, i;

  // Clear loader files
  if (fs.existsSync(loaderCacheDir))
    rimraf.sync(loaderCacheDir);
  ui.log(&#x27;ok&#x27;, &#x27;Loader file cache cleared.&#x27;);

  // Clear packages cache folder
  if (fs.existsSync(packagesCacheDir))
    rimraf.sync(packagesCacheDir);
  ui.log(&#x27;ok&#x27;, &#x27;Package cache cleared.&#x27;);

  // Clear registry cache folders
  files = fs.readdirSync(jspmDir);
  filesLength = files.length;
  for (i = 0; i &#x3c; filesLength; i++) {
    fileName = files[i];
    if (fileName.endsWith(&#x27;-cache&#x27;)) {
      rimraf.sync(path.join(jspmDir, fileName));
      ui.log(&#x27;ok&#x27;, &#x27;%&#x27; + fileName.substr(0, fileName.length - &#x27;-cache&#x27;.length) + &#x27;% cache cleared.&#x27;);
    }
  }

  ui.log(&#x27;warn&#x27;, &#x27;All caches cleared.&#x27;);
  ui.log(&#x27;info&#x27;, &#x27;Please post an issue if you suspect the cache isn\&#x27;t invalidating properly.&#x27;);
  ui.log(&#x27;info&#x27;, &#x27;%jspm install -f% is equivalent to running a cache clear for that specific package tree.&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.core.checkDlLoader" id="apidoc.element.jspm.core.checkDlLoader">
        function <span class="apidocSignatureSpan">jspm.core.</span>checkDlLoader
        <span class="apidocSignatureSpan">(transpilerName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkDlLoader = function (transpilerName) {
  return config.load()
  .then(function() {
    transpilerName = transpilerName || config.loader.transpiler || globalConfig.config.defaultTranspiler;
    var tPkgs = [];
    if (transpilerName === &#x27;traceur&#x27;)
      tPkgs = [&#x27;traceur&#x27;, &#x27;traceur-runtime&#x27;];
    else if (transpilerName === &#x27;babel&#x27;)
      tPkgs = [&#x27;babel&#x27;, &#x27;babel-runtime&#x27;, &#x27;core-js&#x27;];
    else if (transpilerName === &#x27;typescript&#x27;)
      tPkgs = [&#x27;typescript&#x27;];

    tPkgs.forEach(function(p) {
      if (config.loader.baseMap[p])
        if (config.loader.baseMap[p].version !== tPackages[p].split(&#x27;@&#x27;).pop() &#x26;&#x26; !nodeSemver.satisfies(config.loader.baseMap[p].
version, tPackages[p].split(&#x27;@&#x27;).pop()))
          ui.log(&#x27;warn&#x27;, &#x27;`&#x27; + p + &#x27;@&#x27; + config.loader.baseMap[p].version + &#x27;` is unsupported for this version of jspm. Use %jspm
 dl-loader --latest% to update.&#x27;);
    });
  })
  .then(function() {
    return asp(fs.readFile)(path.resolve(config.pjson.packages, &#x27;.loaderversions&#x27;));
  })
  .catch(function(err) {
    if (err.code === &#x27;ENOENT&#x27;)
      return &#x27;&#x27;;
    throw err;
  })
  .then(function(cacheVersions) {
    if (cacheVersions.toString() !== systemVersion)
      return exports.dlLoader(transpilerName);

    // even if version file is fresh, still check files exist
    return asp(fs.readdir)(config.pjson.packages)
    .catch(function(err) {
      if (err.code === &#x27;ENOENT&#x27;)
        return [];
      throw err;
    })
    .then(function(files) {
      if (files.indexOf(&#x27;system.js&#x27;) === -1)
        return exports.dlLoader(transpilerName);
      return exports.dlTranspiler(transpilerName);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .then(function() {
    return config.save();
  })
  .then(function() {
    ui.log(&#x27;ok&#x27;, &#x27;Verified package.json at %&#x27; + path.relative(process.cwd(), config.pjsonPath) + &#x27;%\nVerified
 config file at %&#x27; + path.relative(process.cwd(), config.pjson.configFile) + &#x27;%&#x27;);
  })
  .then(function() {
    return core.<span class="apidocCodeKeywordSpan">checkDlLoader</span>();
  })
  .catch(function(err) {
    ui.log(&#x27;err&#x27;, err &#x26;&#x26; err.stack || err);
  });
};

exports.cacheClear = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.core.dlLoader" id="apidoc.element.jspm.core.dlLoader">
        function <span class="apidocSignatureSpan">jspm.core.</span>dlLoader
        <span class="apidocSignatureSpan">(transpilerName, unminified, edge, latest)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dlLoader = function (transpilerName, unminified, edge, latest) {
  ui.log(&#x27;info&#x27;, &#x27;Looking up loader files...&#x27;);
  var min = unminified ? &#x27;.src&#x27; : &#x27;&#x27;;

  var using = {};

  return config.load()
  .then(function() {
    return asp(mkdirp)(config.pjson.packages);
  })
  .then(function() {
    // delete old versions
    return asp(fs.readdir)(config.pjson.packages);
  })
  .then(function(files) {
    return Promise.all(files.filter(function(file) {
      return file.match(/^(system-csp|system-csp-production|system|es6-module-loader|traceur|babel|system-polyfills|typescript)/);
    }).map(function(file) {
      return asp(fs.unlink)(path.resolve(config.pjson.packages, file));
    }));
  })
  .then(function() {
    return dl(&#x27;systemjs&#x27;, &#x27;github:systemjs/systemjs&#x27;, !edge ? (!latest ? systemVersion : &#x27;^&#x27; + systemVersion) : &#x27;master&#x27;)
    .then(function(version) {
      using.system = version;
      return Promise.all([
        cp(&#x27;systemjs/dist/system&#x27; + min + &#x27;.js&#x27;, &#x27;system.js&#x27;),
        unminified || cp(&#x27;systemjs/dist/system.src.js&#x27;, &#x27;system.src.js&#x27;),
        unminified || cp(&#x27;systemjs/dist/system.js.map&#x27;, &#x27;system.js.map&#x27;),
        cp(&#x27;systemjs/dist/system-csp-production&#x27; + min + &#x27;.js&#x27;, &#x27;system-csp-production.js&#x27;),
        unminified || cp(&#x27;systemjs/dist/system-csp-production.src.js&#x27;, &#x27;system-csp-production.src.js&#x27;),
        unminified || cp(&#x27;systemjs/dist/system-csp-production.js.map&#x27;, &#x27;system-csp-production.js.map&#x27;),
        cp(&#x27;systemjs/dist/system-polyfills&#x27; + min + &#x27;.js&#x27;, &#x27;system-polyfills.js&#x27;),
        unminified || cp(&#x27;systemjs/dist/system-polyfills.src.js&#x27;, &#x27;system-polyfills.src.js&#x27;),
        unminified || cp(&#x27;systemjs/dist/system-polyfills.js.map&#x27;, &#x27;system-polyfills.js.map&#x27;)
      ]);
    });
  })
  .then(function() {
    ui.log(&#x27;info&#x27;, &#x27;\nUsing loader versions:&#x27;);
    ui.log(&#x27;info&#x27;, &#x27;  `systemjs@&#x27; + using.system + &#x27;`&#x27;);

    return asp(fs.writeFile)(path.resolve(config.pjson.packages, &#x27;.loaderversions&#x27;), systemVersion);
  })
  .then(function() {
    return exports.dlTranspiler(transpilerName, latest);
  })
  .then(function() {
    ui.log(&#x27;ok&#x27;, &#x27;Loader files downloaded successfully&#x27;);
  }, function(err) {
    ui.log(&#x27;err&#x27;, err);
    ui.log(&#x27;err&#x27;, &#x27;Error downloading loader files.&#x27;);
    throw err;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .catch(function(err) {
if (err.code === &#x27;ENOENT&#x27;)
  return &#x27;&#x27;;
throw err;
  })
  .then(function(cacheVersions) {
if (cacheVersions.toString() !== systemVersion)
  return exports.<span class="apidocCodeKeywordSpan">dlLoader</span>(transpilerName);

// even if version file is fresh, still check files exist
return asp(fs.readdir)(config.pjson.packages)
.catch(function(err) {
  if (err.code === &#x27;ENOENT&#x27;)
    return [];
  throw err;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.core.dlTranspiler" id="apidoc.element.jspm.core.dlTranspiler">
        function <span class="apidocSignatureSpan">jspm.core.</span>dlTranspiler
        <span class="apidocSignatureSpan">(transpilerName, update)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dlTranspiler = function (transpilerName, update) {
  return config.load()
  .then(function() {
    var installObj = {};

    transpilerName = transpilerName || config.loader.transpiler || globalConfig.config.defaultTranspiler;

    // skip download if not using a transpiler
    if (transpilerName === &#x27;none&#x27;)
      return;

    // read existing transpiler from package.json install
    var target = !update &#x26;&#x26; (config.pjson.devDependencies[transpilerName] || config.pjson.dependencies[transpilerName]);
    if (target)
      installObj[transpilerName] = target.exactName;
    else
      installObj[transpilerName] = transpilerName === &#x27;traceur&#x27; ? tPackages.traceur : transpilerName === &#x27;typescript&#x27; || transpilerName
 == &#x27;ts&#x27; ? tPackages.typescript : tPackages.babel;

    // typescript does not have runtime library
    if (transpilerName !== &#x27;typescript&#x27;) {
      target = !update &#x26;&#x26; (config.pjson.devDependencies[transpilerName + &#x27;-runtime&#x27;] || config.pjson.dependencies[transpilerName
 + &#x27;-runtime&#x27;]);
      if (target)
        installObj[transpilerName + &#x27;-runtime&#x27;] = target.exactName;
      else
        installObj[transpilerName + &#x27;-runtime&#x27;] = transpilerName === &#x27;traceur&#x27; ? tPackages[&#x27;traceur-runtime&#x27;] : tPackages[&#x27;babel
-runtime&#x27;];
    }

    if (transpilerName === &#x27;babel&#x27;) {
      target = !update &#x26;&#x26; (config.pjson.devDependencies[&#x27;core-js&#x27;] || config.pjson.dependencies[&#x27;core-js&#x27;]);
      if (target)
        installObj[&#x27;core-js&#x27;] = target.exactName;
      else
        installObj[&#x27;core-js&#x27;] = tPackages[&#x27;core-js&#x27;];
    }

    // just do a quick install which checks basic existence
    return install.install(installObj, { quick: !update, dev: true, summary: false });
  })
  .then(function() {
    if (config.loader.transpiler !== transpilerName) {
      config.loader.transpiler = transpilerName;

      if (transpilerName !== &#x27;none&#x27;)
        ui.log(&#x27;ok&#x27;, &#x27;ES6 transpiler set to %&#x27; + transpilerName + &#x27;%.&#x27;);
    }
    if (transpilerName === &#x27;babel&#x27;)
      if (!config.loader.babelOptions.optional)
        config.loader.babelOptions.optional = [&#x27;runtime&#x27;, &#x27;optimisation.modules.system&#x27;];
    return config.save();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (err.code === &#x27;ENOENT&#x27;)
        return [];
      throw err;
    })
    .then(function(files) {
      if (files.indexOf(&#x27;system.js&#x27;) === -1)
        return exports.dlLoader(transpilerName);
      return exports.<span class="apidocCodeKeywordSpan">dlTranspiler</span>(transpilerName);
    });
  });
};

// mini registry API usage implementation
var loaderFilesCacheDir = path.join(config.HOME, &#x27;.jspm&#x27;, &#x27;loader-files&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.core.init" id="apidoc.element.jspm.core.init">
        function <span class="apidocSignatureSpan">jspm.core.</span>init
        <span class="apidocSignatureSpan">(basePath, ask)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function init(basePath, ask) {
  if (basePath)
    process.env.jspmConfigPath = path.resolve(basePath, &#x27;package.json&#x27;);
  var relBase = path.relative(process.cwd(), path.dirname(process.env.jspmConfigPath));
  if (relBase !== &#x27;&#x27;)
    ui.log(&#x27;info&#x27;, &#x27;Initializing package at `&#x27; + relBase + &#x27;/`\nUse %jspm init .% to intialize into the current folder.&#x27;);
  return config.load(ask)
  .then(function() {
    return config.save();
  })
  .then(function() {
    ui.log(&#x27;ok&#x27;, &#x27;Verified package.json at %&#x27; + path.relative(process.cwd(), config.pjsonPath) + &#x27;%\nVerified config file at %&#x27; +
path.relative(process.cwd(), config.pjson.configFile) + &#x27;%&#x27;);
  })
  .then(function() {
    return core.checkDlLoader();
  })
  .catch(function(err) {
    ui.log(&#x27;err&#x27;, err &#x26;&#x26; err.stack || err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.core.run" id="apidoc.element.jspm.core.run">
        function <span class="apidocSignatureSpan">jspm.core.</span>run
        <span class="apidocSignatureSpan">(moduleName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (moduleName) {
  return config.load()
  .then(function() {
    var cfg = config.loader.getConfig();
    delete cfg.bundles;
    cfg.baseURL = toFileURL(config.pjson.baseURL);
    System.config(cfg);

    return System.import(moduleName);
  })
  .catch(function(e) {
    ui.log(&#x27;err&#x27;, e.stack || e);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.core.setMode" id="apidoc.element.jspm.core.setMode">
        function <span class="apidocSignatureSpan">jspm.core.</span>setMode
        <span class="apidocSignatureSpan">(modes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMode = function (modes) {
  if (!(modes instanceof Array))
    modes = [modes];

  var msg = &#x27;&#x27;;

  return config.load()
  .then(function() {
    if (modes.indexOf(&#x27;local&#x27;) === -1)
      return true;

    // set local
    Object.keys(config.loader.registries).forEach(function(e) {
      config.loader.registries[e].setLocal();
    });

    msg += &#x27;Loader set to local library sources\n&#x27;;
  })
  .then(function(unmatched) {
    if (modes.indexOf(&#x27;remote&#x27;) === -1)
      return unmatched;

    // set remote
    Object.keys(config.loader.registries).forEach(function(e) {
      config.loader.registries[e].setRemote();
    });

    msg += &#x27;Loader set to CDN library sources\n&#x27;;
  })
  .then(function(unmatched) {
    if (unmatched)
      return ui.log(&#x27;warn&#x27;, &#x27;Invalid mode&#x27;);

    return config.save()
    .then(function() {
      return msg;
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.global_config" id="apidoc.module.jspm.global_config">module jspm.global_config</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.global_config.save" id="apidoc.element.jspm.global_config.save">
        function <span class="apidocSignatureSpan">jspm.global_config.</span>save
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function save() {
  try {
    fs.mkdirSync(HOME + path.sep + &#x27;.jspm&#x27;);
  }
  catch (e) {
    if (e.code !== &#x27;EEXIST&#x27;)
      throw &#x27;Unable to create jspm system folder\n&#x27; + e.stack;
  }
  try {
    lock();
    var existing = readJSONSync(globalConfigFile);
    // only write to a new file if the local changes are different
    if (JSON.stringify(existing) != JSON.stringify(exports.config)) {
      fs.writeFileSync(globalConfigFile, stringify(exports.config));
    }
  }
  catch (e) {
    throw &#x27;Unable to write global configuration file\n&#x27; + e.stack;
  }
  finally {
    unlock();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    output.bundleName = output.bundleName || self.getCanonicalName(toFileURL(path.resolve(opts.outFile)));
    var bundleName = output.bundleName;

    if (!config.loader.bundles)
      config.loader.bundles = {};

    config.loader.bundles[bundleName] = output.modules;
    return config.<span class="apidocCodeKeywordSpan">save</span>()
    .then(function() {
      return output;
    });
  }

  return output;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.global_config.set" id="apidoc.element.jspm.global_config.set">
        function <span class="apidocSignatureSpan">jspm.global_config.</span>set
        <span class="apidocSignatureSpan">(name, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (name, val) {
  var nameParts = name.split(&#x27;.&#x27;);

  var config = exports.config;
  var part;
  while (nameParts.length &#x3e; 1) {
    part = nameParts.shift();
    config[part] = typeof config[part] === &#x27;object&#x27; ? config[part] : {};
    config = config[part];
  }
  if (val !== undefined) {
    config[nameParts[0]] = val;
  }
  else {
    // If no value is specified, then remove property from config
    delete config[nameParts[0]];
  }

  save();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.install" id="apidoc.module.jspm.install">module jspm.install</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.install.install" id="apidoc.element.jspm.install.install">
        function <span class="apidocSignatureSpan">jspm.</span>install
        <span class="apidocSignatureSpan">(targets, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">install = function (targets, options) {
  if (typeof targets === &#x27;string&#x27;) {
    var name = targets;
    targets = {};
    targets[name] = typeof options === &#x27;string&#x27; ? options : &#x27;&#x27;;
    options = typeof options === &#x27;object&#x27; ? options : arguments[2];
  }
  options = options || {};

  return config.load()
  .then(function() {
    installed = installed || config.loader;

    if (options.force)
      config.force = true;

    if (options.link || options.quick)
      options.lock = true;

    var d, existingTargets = {};

    if (!options.production) {
      for (d in config.pjson.devDependencies)
        existingTargets[d] = config.pjson.devDependencies[d];
    }

    for (d in config.pjson.dependencies)
      existingTargets[d] = config.pjson.dependencies[d];

    if (targets === true)
      targets = existingTargets;
    // check and set targets for update
    else if (targets &#x26;&#x26; options.update)
      for (d in targets) {
        if (!existingTargets[d])
          throw &#x27;%&#x27; + d + &#x27;% is not an existing dependency to update.&#x27;;
        targets[d] = existingTargets[d];
      }

    targets = pkg.processDeps(targets, globalConfig.config.defaultRegistry);

    return Promise.all(Object.keys(targets).map(function(name) {
      return install(name, targets[name], options);
    }))
    .then(function() {
      return saveInstall();
    })
    .then(function() {
      // after every install, show fork and resolution summary
      if (options.summary !== false)
        showVersions(true);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (target)
      installObj[&#x27;core-js&#x27;] = target.exactName;
    else
      installObj[&#x27;core-js&#x27;] = tPackages[&#x27;core-js&#x27;];
  }

  // just do a quick install which checks basic existence
  return install.<span class="apidocCodeKeywordSpan">install</span>(installObj, { quick: !update, dev: true, summary: false });
})
.then(function() {
  if (config.loader.transpiler !== transpilerName) {
    config.loader.transpiler = transpilerName;

    if (transpilerName !== &#x27;none&#x27;)
      ui.log(&#x27;ok&#x27;, &#x27;ES6 transpiler set to %&#x27; + transpilerName + &#x27;%.&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.install.clean" id="apidoc.element.jspm.install.clean">
        function <span class="apidocSignatureSpan">jspm.install.</span>clean
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clean() {
  var packageList = [];

  return config.load()
  .then(function() {

    // 1. getDependentPackages for each of baseMap
    Object.keys(config.loader.baseMap).forEach(function(dep) {
      getDependentPackages(config.loader.baseMap[dep].exactName, packageList);
    });

    // 2. now that we have the package list, remove everything not in it
    Object.keys(config.loader.depMap).forEach(function(dep) {
      if (packageList.indexOf(dep) === -1) {
        ui.log(&#x27;info&#x27;, &#x27;Clearing configuration for `&#x27; + dep + &#x27;`&#x27;);
        delete config.loader.depMap[dep];
      }
    });

    // 3. remove package.json overrides which will never match any packages
    var usedOverrides = [];
    packageList.forEach(function(pkgName) {
      var pkgVersion = pkgName.split(&#x27;@&#x27;).pop();
      pkgName = pkgName.substr(0, pkgName.length - pkgVersion.length - 1);

      var overrideVersion = Object.keys(config.pjson.overrides)
      .filter(function(overrideName) {
        return overrideName.startsWith(pkgName + &#x27;@&#x27;);
      })
      .map(function(overrideName) {
        return overrideName.split(&#x27;@&#x27;).pop();
      })
      .filter(function(overrideVersion) {
        return semver.match(&#x27;^&#x27; + overrideVersion, pkgVersion);
      })
      .sort(semver.compare).pop();
      if (overrideVersion)
        usedOverrides.push(pkgName + &#x27;@&#x27; + overrideVersion);
    });
    Object.keys(config.pjson.overrides).forEach(function(overrideName) {
      if (usedOverrides.indexOf(overrideName) == -1) {
        ui.log(&#x27;info&#x27;, &#x27;Removing unused package.json override `&#x27; + overrideName + &#x27;`&#x27;);
        delete config.pjson.overrides[overrideName];
      }
    });
  })

  .then(function() {
    return asp(fs.lstat)(config.pjson.packages)
    .catch(function(e) {
      if (e.code == &#x27;ENOENT&#x27;)
        return;
      throw e;
    }).then(function(stats) {
      // Skip if jspm_packages is symlinked or not existing
      if (!stats || stats.isSymbolicLink())
        return;

      // 4. Remove packages in .dependencies.json that aren&#x27;t used at all
      Object.keys(config.deps).forEach(function(dep) {
        if (packageList.indexOf(dep) == -1)
          delete config.deps[dep];
      });

      // 5. Remove anything from jspm_packages not in this list
      return readDirWithDepth(config.pjson.packages, function(dirname) {
        if (dirname.split(path.sep).pop().indexOf(&#x27;@&#x27;) &#x3c;= 0)
          return true;
      })
      .then(function(packageDirs) {
        return Promise.all(
        packageDirs
        .filter(function(dir) {
          var exactName = path.relative(config.pjson.packages, dir).replace(path.sep, &#x27;:&#x27;).replace(/\\/g, &#x27;/&#x27;); // (win)
          var remove = packageList.indexOf(exactName) === -1;
          if (remove)
            ui.log(&#x27;info&#x27;, &#x27;Removing package files for `&#x27; + exactName + &#x27;`&#x27;);
          return remove;
        })
        .map(function(dir) {
          return asp(rimraf)(dir)
          .then(function() {
            var filename = dir + &#x27;.js&#x27;;
            return new Promise(function(resolve) {
              fs.exists(filename, resolve);
            }).then(function(exists) {
              if (exists) return asp(fs.unlink)(filename);
            });
          })
          .then(function() {
            return cascadeDelete(dir);
          });
        }));
      });
    });
  })

  .then(function() {
    return config.save();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.install.resolveOnly" id="apidoc.element.jspm.install.resolveOnly">
        function <span class="apidocSignatureSpan">jspm.install.</span>resolveOnly
        <span class="apidocSignatureSpan">(pkg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolveOnly = function (pkg) {
  pkg = new PackageName(pkg);

  if (!pkg.version || !pkg.registry) {
    ui.log(&#x27;warn&#x27;, &#x27;Resolve --only must take an exact package of the form `registry:pkg@version`.&#x27;);
    return Promise.reject();
  }

  var didSomething = false;

  return config.load()
  .then(function() {
    Object.keys(config.loader.baseMap).forEach(function(name) {
      var curPkg = config.loader.baseMap[name];
      if (curPkg.registry === pkg.registry &#x26;&#x26; curPkg.package === pkg.package &#x26;&#x26; curPkg.version !== pkg.version) {
        didSomething = true;
        ui.log(&#x27;info&#x27;, &#x27;Primary install &#x27; + getUpdateRangeText(curPkg, pkg));
        config.loader.baseMap[name] = pkg.copy();
      }
    });

    Object.keys(config.loader.depMap).forEach(function(parent) {
      var curMap = config.loader.depMap[parent];
      Object.keys(curMap).forEach(function(name) {
        var curPkg = curMap[name];
        if (curPkg.registry === pkg.registry &#x26;&#x26; curPkg.package === pkg.package &#x26;&#x26; curPkg.version !== pkg.version) {
          didSomething = true;
          ui.log(&#x27;info&#x27;, &#x27;In %&#x27; + parent + &#x27;% &#x27; + getUpdateRangeText(curPkg, pkg));
          curMap[name] = pkg.copy();
        }
      });
    });

    return config.save();
  })
  .then(function() {
    if (didSomething)
      ui.log(&#x27;ok&#x27;, &#x27;Resolution to only use `&#x27; + pkg.exactName + &#x27;` completed successfully.&#x27;);
    else
      ui.log(&#x27;ok&#x27;, &#x27;`&#x27; + pkg.exactName + &#x27;` is already the only version of the package in use.&#x27;);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.install.showInstallGraph" id="apidoc.element.jspm.install.showInstallGraph">
        function <span class="apidocSignatureSpan">jspm.install.</span>showInstallGraph
        <span class="apidocSignatureSpan">(pkg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function showInstallGraph(pkg) {
  installed = installed || config.loader;
  pkg = new PackageName(pkg);
  var lastParent;
  var found;
  return loadExistingForkRanges(pkg, config.loader.local)
  .then(function() {
    ui.log(&#x27;info&#x27;, &#x27;\nInstalled versions of %&#x27; + pkg.name + &#x27;%&#x27;);
    visitForkRanges(installed, pkg, null, null, function(name, parent, resolved, range) {
      found = true;
      if (range.version === &#x27;&#x27;)
        range.version = &#x27;*&#x27;;
      var rangeVersion = range.name === resolved.name ? range.version : range.exactName;
      if (range.version === &#x27;*&#x27;)
        range.version = &#x27;&#x27;;

      if (!parent)
        ui.log(&#x27;info&#x27;, &#x27;\n       %&#x27; + name + &#x27;% `&#x27; + resolved.version + &#x27;` (&#x27; + rangeVersion + &#x27;)&#x27;);
      else {
        if (lastParent !== parent) {
          ui.log(&#x27;info&#x27;, &#x27;\n  &#x27; + parent);
          lastParent = parent;
        }
        ui.log(&#x27;info&#x27;, &#x27;    &#x27; + name + &#x27; `&#x27; + resolved.version + &#x27;` (&#x27; + rangeVersion + &#x27;)&#x27;);
      }
    });
    if (!found)
      ui.log(&#x27;warn&#x27;, &#x27;Package `&#x27; + pkg.name + &#x27;` not found.&#x27;);
    ui.log(&#x27;&#x27;);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.install.showVersions" id="apidoc.element.jspm.install.showVersions">
        function <span class="apidocSignatureSpan">jspm.install.</span>showVersions
        <span class="apidocSignatureSpan">(forks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function showVersions(forks) {
  installed = installed || config.loader;

  var versions = {};
  var haveLinked = false;
  var linkedVersions = {};

  function addDep(dep) {
    var vList = versions[dep.name] = versions[dep.name] || [];
    var version = dep.version;
    try {
      if (fs.readlinkSync(dep.getPath()))
        linkedVersions[dep.exactName] = true;
    }
    catch(e) {}
    if (vList.indexOf(version) === -1)
      vList.push(version);
  }

  Object.keys(installed.baseMap).forEach(function(dep) {
    addDep(installed.baseMap[dep]);
  });
  Object.keys(installed.depMap).forEach(function(parent) {
    var curMap = installed.depMap[parent];
    Object.keys(curMap).forEach(function(dep) {
      addDep(curMap[dep]);
    });
  });

  versions = alphabetize(versions);

  var vLen = Object.keys(versions).map(function(dep) {
    return dep.length;
  }).reduce(function(a, b) {
    return Math.max(a, b);
  }, 0);

  var shownIntro = false;

  Object.keys(versions).forEach(function(dep) {
    var vList = versions[dep].sort(semver.compare).map(function(version) {
      if (linkedVersions[dep + &#x27;@&#x27; + version]) {
        haveLinked = true;
        return &#x27;%&#x27; + version + &#x27;%&#x27;;
      }
      else
        return &#x27;`&#x27; + version + &#x27;`&#x27;;
    });

    if (forks &#x26;&#x26; vList.length === 1)
      return;

    if (!shownIntro) {
      ui.log(&#x27;info&#x27;, &#x27;Installed &#x27; + (forks ? &#x27;Forks&#x27; : &#x27;Versions&#x27;) + &#x27;\n&#x27;);
      shownIntro = true;
    }

    var padding = vLen - dep.length;
    var paddingString = &#x27;&#x27;;
    while(padding--)
      paddingString += &#x27; &#x27;;

    ui.log(&#x27;info&#x27;, &#x27;  &#x27; + paddingString + &#x27;%&#x27; + dep + &#x27;% &#x27; + vList.join(&#x27; &#x27;));
  });

  if (haveLinked) {
    ui.log(&#x27;info&#x27;, &#x27;\nBold versions are linked. To unlink use %jspm install --unlink [name]%.&#x27;);
  }
  if (shownIntro) {
    ui.log(&#x27;info&#x27;, &#x27;\nTo inspect individual package constraints, use %jspm inspect registry:name%.\n&#x27;);
  }
  else if (forks) {
    ui.log(&#x27;ok&#x27;, &#x27;Install tree has no forks.&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.install.uninstall" id="apidoc.element.jspm.install.uninstall">
        function <span class="apidocSignatureSpan">jspm.install.</span>uninstall
        <span class="apidocSignatureSpan">(names)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uninstall = function (names) {
  if (!(names instanceof Array))
    names = [names];

  return config.load()
  .then(function() {
    installed = installed || config.loader;

    names.forEach(function(name) {
      if (!config.pjson.dependencies[name] &#x26;&#x26; !config.pjson.devDependencies[name])
        ui.log(&#x27;warn&#x27;, &#x27;Dependency %&#x27; + name + &#x27;% is not an existing primary install.&#x27;);

      delete config.pjson.dependencies[name];
      delete config.pjson.devDependencies[name];
      delete installed.baseMap[name];
    });

    return clean();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.link" id="apidoc.module.jspm.link">module jspm.link</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.link.link" id="apidoc.element.jspm.link.link">
        function <span class="apidocSignatureSpan">jspm.</span>link
        <span class="apidocSignatureSpan">(name, dir, force)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">link = function (name, dir, force) {
  var pjson, linkDir, pkg;

  return Promise.resolve()
  .then(function() {
    // try to get registry, package
    return readJSON(path.resolve(dir, &#x27;package.json&#x27;));
  })
  .then(function(_pjson) {
    try {
      pkg = new PackageName(name);
    }
    catch(e) {
      pkg = {};
    }

    var packageName = pkg.package || _pjson.jspm &#x26;&#x26; _pjson.jspm.name || _pjson.name;
    var registry = pkg.registry || _pjson.jspm &#x26;&#x26; _pjson.jspm.registry || _pjson.registry;
    var version = pkg.version || _pjson.jspm &#x26;&#x26; _pjson.jspm.version || _pjson.version;

    if (!packageName)
      throw &#x27;Package name not specified.&#x27;;
    if (!registry)
      throw &#x27;Package registry not specified.&#x27;;
    if (!version)
      throw &#x27;Package version not specified.&#x27;;

    pkg = new PackageName(registry + &#x27;:&#x27; + packageName + &#x27;@&#x27; + version);

    return package.derivePackageConfig(pkg, _pjson);
  })
  .then(function(_pjson) {
    pjson = _pjson;

    linkDir = path.resolve(config.HOME, &#x27;.jspm&#x27;, &#x27;linked&#x27;, pkg.registry, pkg.exactPackage);
    try {
      if (fs.existsSync(linkDir)) {
        return (force ? Promise.resolve(true) : ui.confirm(&#x27;`&#x27; + pkg.exactName + &#x27;` is already linked, are you sure you want to
override it (use -y to skip this prompt in future)?&#x27;, true))
        .then(function(override) {
          return !override;
        });
      }
    }
    catch(e) {}
  })
  // clear the directory
  .then(function(abort) {
    if (abort)
      return true;

    return asp(rimraf)(linkDir)
    // create it
    .then(function() {
      if (pjson.directories) {
        if (pjson.directories.lib) {
          dir = path.resolve(dir, pjson.directories.lib);
          delete pjson.directories.lib;
        }
        if (pjson.directories.dist) {
          dir = path.resolve(dir, pjson.directories.dist);
          delete pjson.directories.dist;
        }
      }

      return asp(mkdirp)(linkDir);
    })
    // copy the files to the local cache folder
    .then(function() {
      return asp(ncp)(dir, linkDir);
    })
    // run the jspm operations on the folder to process it
    .then(function() {
      return package.processPackage(pkg, linkDir, pjson, function() {});
    })
    .then(function() {
      return asp(fs.writeFile)(path.resolve(linkDir, &#x27;.jspm.json&#x27;), JSON.stringify(pjson, null, 2));
    });
  })
  .then(function(aborted) {
    if (!aborted)
      ui.log(&#x27;ok&#x27;, &#x27;Package linked as `&#x27; + pkg.exactName + &#x27;`&#x27;);
    else
      ui.log(&#x27;info&#x27;, &#x27;Link operation aborted.&#x27;);
  }, function(err) {
    ui.log(&#x27;err&#x27;, err.stack || err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.link.lookup" id="apidoc.element.jspm.link.lookup">
        function <span class="apidocSignatureSpan">jspm.link.</span>lookup
        <span class="apidocSignatureSpan">(pkg, edge)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookup = function (pkg, edge) {
  var packageParts = pkg.package.split(&#x27;/&#x27;);
  var packagePart = packageParts.pop();
  var linkFolder = path.resolve(config.HOME, &#x27;.jspm&#x27;, &#x27;linked&#x27;, pkg.registry, packageParts.join(&#x27;/&#x27;));

  return asp(fs.readdir)(linkFolder)
  .then(function(files) {
    var versions = {};
    var hasVersions;
    files
    .filter(function(file) {
      return file.substr(0, file.lastIndexOf(&#x27;@&#x27;)) === packagePart;
    })
    .forEach(function(file) {
      hasVersions = true;
      versions[file.substr(file.lastIndexOf(&#x27;@&#x27;) + 1)] = { hash: &#x27;hash&#x27; };
    });

    if (!hasVersions)
      throw &#x27;No version match found for `&#x27; + pkg.exactName + &#x27;`&#x27;;

    return function(version) {
      var lookupObj = package.getVersionMatch(version, versions, {edge: edge});
      if (!lookupObj)
        return;

      return pkg.copy().setVersion(lookupObj.version);
    };
  }, function(err) {
    if (err.code === &#x27;ENOENT&#x27;)
      throw &#x27;No linked versions found for `&#x27; + pkg.name + &#x27;`&#x27;;
    throw err;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function dl(name, repo, version) {
var pkg = new PackageName(repo);
var endpoint = registry.load(pkg.registry);
var vMatch, vMatchLookup;
var dlDir = path.resolve(loaderFilesCacheDir, name);

return endpoint.<span class="apidocCodeKeywordSpan">lookup</span>(pkg.package)
.then(function(lookup) {
  if (!(nodeSemver.validRange(version)))
    vMatch = version;
  else
    vMatch = Object.keys(lookup.versions)
    .filter(nodeSemver.valid)
    .sort(nodeSemver.compare).reverse()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.link.symlink" id="apidoc.element.jspm.link.symlink">
        function <span class="apidocSignatureSpan">jspm.link.</span>symlink
        <span class="apidocSignatureSpan">(pkg, downloadDeps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">symlink = function (pkg, downloadDeps) {
  var linkDir = path.resolve(config.HOME, &#x27;.jspm&#x27;, &#x27;linked&#x27;, pkg.registry, pkg.exactPackage);
  var dir = path.resolve(config.pjson.packages, pkg.registry, pkg.exactPackage);
  var pjson;

  var fresh = false;

  return asp(fs.readlink)(dir)
  .then(function(linkString) {
    if (linkString === linkDir)
      return asp(fs.unlink)(dir);

    return Promise.resolve(ui.confirm(&#x27;`&#x27; + pkg.exactName + &#x27;` already linked, are you sure you want to link over it?&#x27;, true))
    .then(function(remove) {
      if (!remove)
        throw &#x27;Aborted.&#x27;;
      return asp(fs.unlink)(dir);
    });

  }, function(err) {
    if (err.code === &#x27;ENOENT&#x27;)
      return;
    if (err.code !== &#x27;EINVAL&#x27; &#x26;&#x26; err.code !== &#x27;UNKNOWN&#x27;)
      throw err;

    return Promise.resolve(ui.confirm(&#x27;`&#x27; + pkg.exactName + &#x27;` already installed, are you sure you want to link over it?&#x27;, true))
    .then(function(remove) {
      if (!remove)
        throw &#x27;Aborted.&#x27;;
      return asp(rimraf)(dir);
    });
  })
  .then(function() {
    return asp(mkdirp)(path.resolve(dir, &#x27;..&#x27;))
    .then(function() {
      return asp(fs.symlink)(linkDir, dir, &#x27;junction&#x27;);
    })
    .then(function() {
      return readJSON(path.resolve(dir, &#x27;.jspm.json&#x27;));
    })
    .then(function(_pjson) {
      pjson = config.derivePackageConfig(_pjson);
      return package.createMain(pkg, pjson, dir);
    });
  })
  .then(function() {
    downloadDeps(package.processDeps(pjson.dependencies, pjson.registry));
    return fresh;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!resolution.registry)
  return;

// -- download --
return Promise.resolve()
.then(function() {
  if (options.link)
    return link.<span class="apidocCodeKeywordSpan">symlink</span>(resolution, downloadDeps);

  if (options.inject)
    return pkg.inject(resolution, downloadDeps);

  // override, quick, unlink options passed
  return pkg.download(resolution, options, downloadDeps);
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.package" id="apidoc.module.jspm.package">module jspm.package</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.package.createMain" id="apidoc.element.jspm.package.createMain">
        function <span class="apidocSignatureSpan">jspm.package.</span>createMain
        <span class="apidocSignatureSpan">(pkg, pjson, downloadDir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createMain = function (pkg, pjson, downloadDir) {
  var lastNamePart, main;
  var mainPath;
  var pluginMain;

  return Promise.resolve()

  // create the main entry point
  .then(function() {
    lastNamePart = pkg.name.split(&#x27;/&#x27;).pop().split(&#x27;:&#x27;).pop();
    main = typeof pjson.main === &#x27;string&#x27; &#x26;&#x26; pjson.main;

    // we don&#x27;t need to ensure it exists for plugin mains
    // as they can have custom locate functions
    if (main &#x26;&#x26; main.indexOf(&#x27;!&#x27;) !== -1) {
      pluginMain = true;
      return true;
    }

    if (!main)
      return false;

    if (main.startsWith(&#x27;./&#x27;)) {
      main = main.substr(2);
    }

    return new Promise(function(resolve) {
      // Check to see if main points to an actual file or not
      // i.e. does it include extension.
      mainPath = path.resolve(downloadDir, main);
      fs.exists(mainPath, resolve);
    });
  })
  .then(function(exists) {
    main = main || &#x27;index&#x27;;

    return new Promise(function(resolve) {
      // `main` does not have extension (or it does not point to an actual file).
      // Try again with `.js` extension
      mainPath = path.resolve(downloadDir, main + &#x27;.js&#x27;);
      fs.exists(mainPath, resolve);
    })
    .then(function(_exists) {
      if (!_exists)
        mainPath = path.resolve(downloadDir, main);
      return exists || _exists;
    });
  })
  .then(function(exists) {
    if (exists)
      return exists;

    main = lastNamePart;

    if (main.endsWith(&#x27;.js&#x27;))
      main = main.substr(0, main.length - 3);

    return new Promise(function(resolve) {
      mainPath = path.resolve(downloadDir, main + &#x27;.js&#x27;);
      fs.exists(mainPath, resolve);
    });
  })
  .then(function(exists) {
    // don&#x27;t create a main if it doesn&#x27;t exist
    if (!exists) {
      if (pjson.main !== false)
        ui.log(&#x27;warn&#x27;, &#x27;Main entry point not found for `&#x27; + pkg.exactName + &#x27;`.\nAdjust this property in the package.json or with
 an override, setting %&#x22;main&#x22;: false% if this is the intention.\n&#x27;);
      return;
    }

    // create the main pointer
    var mainFile = path.resolve(downloadDir, &#x27;../&#x27; + lastNamePart + &#x27;@&#x27; + pkg.version + &#x27;.js&#x27;);

    // plugin mains are redirected by CommonJS
    if (pluginMain)
      return asp(fs.writeFile)(mainFile, getRedirectContents(&#x27;cjs&#x27;, pkg.exactName + &#x27;/&#x27; + main));

    // otherwise detect the format of the main
    return asp(fs.readFile)(mainPath)
    .catch(function(err) {
      if (err.code == &#x27;EISDIR&#x27;)
        return;
      throw err;
    })
    .then(function(source) {
      if (typeof source == &#x27;undefined&#x27;)
        return;
      var format = pjson.format || build.detectFormat(source.toString()).format;

      return asp(fs.writeFile)(mainFile, getRedirectContents(format, pkg.exactName + &#x27;/&#x27; + main));
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return asp(fs.symlink)(linkDir, dir, &#x27;junction&#x27;);
    })
    .then(function() {
      return readJSON(path.resolve(dir, &#x27;.jspm.json&#x27;));
    })
    .then(function(_pjson) {
      pjson = config.derivePackageConfig(_pjson);
      return package.<span class="apidocCodeKeywordSpan">createMain</span>(pkg, pjson, dir);
    });
  })
  .then(function() {
    downloadDeps(package.processDeps(pjson.dependencies, pjson.registry));
    return fresh;
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.package.derivePackageConfig" id="apidoc.element.jspm.package.derivePackageConfig">
        function <span class="apidocSignatureSpan">jspm.package.</span>derivePackageConfig
        <span class="apidocSignatureSpan">(pkg, pjson, override)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function derivePackageConfig(pkg, pjson, override) {
  pjson = config.derivePackageConfig(pjson, override);

  var endpoint = registry.load(pjson.registry || pkg.registry);
  return Promise.resolve(endpoint.processPackageConfig ? endpoint.processPackageConfig(pjson, pkg.exactName) : pjson)
  .then(function(pjson) {
    if (!pjson)
      throw new Error(&#x27;processPackageConfig must return the processed package.json object.&#x27;);
    pjson.registry = pjson.registry || pkg.registry;
    return pjson;
  })
  .catch(function() {
    throw &#x27;Error processing package config for `&#x27; + pkg.name + &#x27;`.&#x27;;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!registry)
  throw &#x27;Package registry not specified.&#x27;;
if (!version)
  throw &#x27;Package version not specified.&#x27;;

pkg = new PackageName(registry + &#x27;:&#x27; + packageName + &#x27;@&#x27; + version);

return package.<span class="apidocCodeKeywordSpan">derivePackageConfig</span>(pkg, _pjson);
  })
  .then(function(_pjson) {
pjson = _pjson;

linkDir = path.resolve(config.HOME, &#x27;.jspm&#x27;, &#x27;linked&#x27;, pkg.registry, pkg.exactPackage);
try {
  if (fs.existsSync(linkDir)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.package.download" id="apidoc.element.jspm.package.download">
        function <span class="apidocSignatureSpan">jspm.package.</span>download
        <span class="apidocSignatureSpan">(pkg, options, installDeps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">download = function (pkg, options, installDeps) {
  var sentDeps;
  // called twice, ensure we don&#x27;t duplicate install requests back
  function depsCallback(depRanges) {
    if (sentDeps)
      Object.keys(depRanges).forEach(function(dep) {
        if (sentDeps.indexOf(dep) != -1)
          delete depRanges[dep];
      });
    else
      sentDeps = Object.keys(depRanges);
    if (installDeps)
      installDeps(depRanges);
    return depRanges;
  }

  // download queue
  if (downloading[pkg.exactName]) {
    downloading[pkg.exactName].preload.then(depsCallback);
    downloading[pkg.exactName].postload.then(depsCallback);
    return downloading[pkg.exactName].promise;
  }
  var postloadResolve, preloadResolve;
  downloading[pkg.exactName] = {
    preload: new Promise(function(resolve) {
      preloadResolve = resolve;
    })
    .then(depsCallback),
    postload: new Promise(function(resolve) {
      postloadResolve = resolve;
    })
    .then(depsCallback)
  };

  // download
  var override = options.override;
  var downloadDir = pkg.getPath();
  var getPackageConfigPromise;

  downloading[pkg.exactName].promise = Promise.resolve()
  .then(function() {
    // if we have no constraint information, it&#x27;s immediately a not-found
    if (!config.deps[pkg.exactName])
      return { notfound: true };

    // otherwise check the folder info
    return getPackageDirInfo(downloadDir);
  })
  .then(function(dirInfo) {
    if (dirInfo.linked &#x26;&#x26; !options.unlink)
      return preloadResolve(config.deps[pkg.exactName]);

    var cacheDir = path.resolve(config.HOME, &#x27;.jspm&#x27;, &#x27;packages&#x27;, pkg.registry, pkg.exactPackage);

    var endpoint = registry.load(pkg.registry);

    var hash;
    var fullHash;
    var meta;

    var fresh;

    return (options.quick &#x26;&#x26; dirInfo.hash ? Promise.resolve(true) : Promise.all([
      // ensure we have the hash from the lookup
      _pkg.lookup(pkg, options.edge)
      .then(function() {
        var lookupObj = lookups[pkg.package][pkg.version];
        if (!lookupObj &#x26;&#x26; !options.link)
          throw &#x27;Unable to resolve version %&#x27; + pkg.version + &#x27;% for `&#x27; + pkg.package + &#x27;`.&#x27;;

        if (lookupObj) {
          hash = lookupObj.hash;
          meta = lookupObj.meta;
        }
        // linked packages have no lookup object
        else {
          hash = &#x27;&#x27;;
          meta = {};
        }
      }),

      // and the override
      Promise.resolve()
      .then(function() {
        // load the registry endpoint
        var endpoint = registry.load(globalConfig.config.defaultRegistry);

        // get the override
        if (endpoint.getOverride) {
          if (!override) {
            var overrideVersion = Object.keys(config.pjson.overrides)
            .filter(function(overrideName) {
              return overrideName.startsWith(pkg.name + &#x27;@&#x27;);
            })
            .map(function(overrideName) {
              return overrideName.split(&#x27;@&#x27;).pop();
            })
            .filter(function(overrideVersion) {
              return semver.match(&#x27;^&#x27; + overrideVersion, pkg.version);
            })
            .sort(semver.compare).pop();
            if (overrideVersion) {
              override = config.pjson.overrides[pkg.name + &#x27;@&#x27; + overrideVersion];
              ui.log(&#x27;warn&#x27;, &#x27;Using local override for `&#x27; + pkg.exactName + &#x27;`&#x27;);
            }
          }
          return endpoint.getOverride(pkg.registry, pkg.package, pkg.version, override);
        }

        return override;
      })
      .then(function(_override) {
        override = _override;
      })
    ]))
    .then(function() {
      if (options.quick &#x26;&#x26; dirInfo.hash)
        return true;

      // create the full package hash by combining it with the override and registry code hash
      fullHash = hash + md5(JSON.stringify(override || {})) + endpoint.versionString + jspmVersion + &#x27;.1&#x27;;

      if (config.force)
        return false;

      return dirInfo.hash === fullHash;
    })
    .then(function(_fresh) {
      fresh = _fresh;
      if (fresh) {
        // this can&#x27;t trigger twice, so if its a second call its just a noop
        preloadResolv ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    throw e;
  });
})
.then(function(cached) {
  if (cached)
    return;

  return endpoint.<span class="apidocCodeKeywordSpan">download</span>(pkg.package, vMatch, vMatchLookup.hash, vMatchLookup.meta,
dlDir)
  .then(function() {
    return fs.writeFile(path.resolve(dlDir, &#x27;.hash&#x27;), vMatchLookup.hash);
  });
})
.then(function() {
  return vMatch;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.package.getVersionMatch" id="apidoc.element.jspm.package.getVersionMatch">
        function <span class="apidocSignatureSpan">jspm.package.</span>getVersionMatch
        <span class="apidocSignatureSpan">(pkgVersion, versions, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getVersionMatch(pkgVersion, versions, options) {
  // unescape pkgVersion for comparison
  if (pkgVersion)
    pkgVersion = decodeURIComponent(pkgVersion);

  var version;
  var stableSemver = [];
  var unstableSemver = [];
  var stableExact = [];
  var unstableExact = [];
  var edge = options &#x26;&#x26; options.edge;

  Object.keys(versions).forEach(function(v) {
    version = versions[v];
    var stable = version.stable;
    var semverMatch = v.match(semver.semverRegEx);
    var valid = semverMatch &#x26;&#x26; semverMatch[1] &#x26;&#x26; semverMatch[2] &#x26;&#x26; semverMatch[3];
    var pre = valid &#x26;&#x26; semverMatch[4];

    // store a reverse lookup
    version.version = v;

    // ignore non-semver or prerelease, unless explictly marked as stable
    if (!valid) {
      // unstable unless explicitly stable. in --edge prioritize all after &#x27;master&#x27;
      if (stable &#x26;&#x26; !edge)
        stableExact.push(v);
      else
        unstableExact.push(v);
    }
    // stable unless explicitly unstable or indetermate and a prerelease
    // --edge considers all semver to be stable
    else if (!edge &#x26;&#x26; (stable === false || (stable !== true &#x26;&#x26; pre)))
      unstableSemver.push(v);
    else
      stableSemver.push(v);
  });

  function compareDesc(a, b) {
    return semver.compare(b, a);
  }

  if (!pkgVersion) {
    var latest = options &#x26;&#x26; options.latestVersion &#x26;&#x26; versions[options.latestVersion];
    if (!edge &#x26;&#x26; latest)
      return latest;
    stableSemver.sort(compareDesc);

    if (stableSemver[0])
      return versions[stableSemver[0]];

    unstableSemver.sort(compareDesc);
    if (unstableSemver[0])
      return versions[unstableSemver[0]];

    if (latest)
      return latest;

    stableExact.sort();
    if (stableExact[0])
      return versions[stableExact[0]];

    // an ugly practicality. ideally designed out in future.
    if (versions.master)
      return versions.master;

    unstableExact.sort();
    if (unstableExact[0])
      return versions[unstableExact[0]];
  }
  else {
    var i, ver;
    stableSemver.sort(compareDesc);
    // find highest stable match in tags
    for (i = 0; i &#x3c; stableSemver.length; i++) {
      ver = stableSemver[i];
      var match = edge ? semver.matchUnstable : semver.match;
      if (match(pkgVersion, ver))
        return versions[ver];
    }
    unstableSemver.sort(compareDesc);
    for (i = 0; i &#x3c; unstableSemver.length; i++) {
      ver = unstableSemver[i];
      if (semver.match(pkgVersion, ver))
        return versions[ver];
    }
    // finally check for an exact tag match
    if (versions[pkgVersion])
      return versions[pkgVersion];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    versions[file.substr(file.lastIndexOf(&#x27;@&#x27;) + 1)] = { hash: &#x27;hash&#x27; };
  });

  if (!hasVersions)
    throw &#x27;No version match found for `&#x27; + pkg.exactName + &#x27;`&#x27;;

  return function(version) {
    var lookupObj = package.<span class="apidocCodeKeywordSpan">getVersionMatch</span>(version, versions, {edge: edge});
    if (!lookupObj)
      return;

    return pkg.copy().setVersion(lookupObj.version);
  };
}, function(err) {
  if (err.code === &#x27;ENOENT&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.package.inject" id="apidoc.element.jspm.package.inject">
        function <span class="apidocSignatureSpan">jspm.package.</span>inject
        <span class="apidocSignatureSpan">(pkg, depLoad)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inject = function (pkg, depLoad) {
  if (injecting[pkg.exactName]) {
    injecting[pkg.exactName].depLoad.then(function(depMap) {
      depLoad(depMap);
      return depMap;
    });
    return injecting[pkg.exactName].promise;
  }

  injecting[pkg.exactName] = {};

  var depResolve, depReject;
  injecting[pkg.exactName].depLoad = new Promise(function(resolve, reject) {
    depResolve = resolve;
    depReject = reject;
  })
  .then(function(depMap) {
    depLoad(depMap);
    return depMap;
  });

  var remote = registry.load(pkg.registry).remote;

  if (!remote)
    throw &#x27;Cannot inject from registry %&#x27; + pkg.registry + &#x27;% as it has no remote.&#x27;;

  // NB remove rejectUnauthorized
  var url = remote + (remote.endsWith(&#x27;/&#x27;) ? &#x27;&#x27; : &#x27;/&#x27;) + pkg.exactName.substr(pkg.exactName.indexOf(&#x27;:&#x27;) + 1) + &#x27;/.jspm.json&#x27;;
  injecting[pkg.exactName].promise = asp(request)({
    method: &#x27;get&#x27;,
    url: url,
    rejectUnauthorized: false
  }).then(function(res) {
    if (res.statusCode !== 200)
      throw new Error(&#x27;Error requesting package.json for `&#x27; + pkg.exactName + &#x27;` at %&#x27; + url + &#x27;%.&#x27;);

    try {
      return JSON.parse(res.body);
    }
    catch(e) {
      throw new Error(&#x27;Unable to parse package.json&#x27;);
    }
  })
  .then(function(pjson) {
    depResolve(processDeps(pjson.dependencies, pjson.registry));
    return pjson;
  }, depReject);
  return injecting[pkg.exactName].promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// -- download --
return Promise.resolve()
.then(function() {
  if (options.link)
    return link.symlink(resolution, downloadDeps);

  if (options.inject)
    return pkg.<span class="apidocCodeKeywordSpan">inject</span>(resolution, downloadDeps);

  // override, quick, unlink options passed
  return pkg.download(resolution, options, downloadDeps);
})
.then(function(fresh) {
  resolution.fresh = fresh;
  // log sub-dependencies before child completion for nicer output
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.package.locate" id="apidoc.element.jspm.package.locate">
        function <span class="apidocSignatureSpan">jspm.package.</span>locate
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">locate = function (target) {
  if (!target.registry) {
    target = new PackageName(target.exactName);
    target.setRegistry(globalConfig.config.defaultRegistry);
  }

  var endpoint = registry.load(target.registry);

  if (!endpoint.locate)
    return Promise.resolve(target);

  locateCache[target.registry] = locateCache[target.registry] || {};

  // NB enable versioned locate
  return Promise.resolve()
  .then(function() {
    if (locateCache[target.registry][target.package])
      return locateCache[target.registry][target.package];

    return (locateCache[target.registry][target.package] = Promise.resolve(endpoint.locate(target.package))
    .then(function(located) {
      // NB support versioned registry
      if (target.registry === globalConfig.config.defaultRegistry)
        registryCache[target.package] = located.redirect;
      return located;
    }));
  })
  .then(function(located) {
    if (!located)
      return target;

    if (located.redirect) {
      var newTarget = new PackageName(located.redirect);
      newTarget.setVersion(target.version);
      return _pkg.locate(newTarget);
    }

    if (located.notfound)
      throw &#x27;Repo `&#x27; + target.name + &#x27;` not found.&#x27; +
        (target.registry != &#x27;npm&#x27; &#x26;&#x26; target.package.split(&#x27;/&#x27;).length == 1 ? &#x27; Perhaps try %jspm install npm:&#x27; + target.package + &#x27;%.&#x27; : &#x27;&#x27;);

    throw &#x27;Invalid registry locate response for %&#x27; + target.registry + &#x27;%&#x27;;
  }, function() {
    throw &#x27;Error locating `&#x27; + target.name + &#x27;`.&#x27;;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var existing;

  return Promise.resolve()
  .then(function() {
if (options.link)
  return Promise.resolve(target);

return pkg.<span class="apidocCodeKeywordSpan">locate</span>(target);
  })
  .then(function(located) {
target = located;

config.loader.ensureRegistry(located.registry, options.inject);

if (options.link)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.package.lookup" id="apidoc.element.jspm.package.lookup">
        function <span class="apidocSignatureSpan">jspm.package.</span>lookup
        <span class="apidocSignatureSpan">(pkg, edge)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookup = function (pkg, edge) {
  return Promise.resolve()

  // load the version map
  .then(function() {
    if (lookupPromises[pkg.package])
      return lookupPromises[pkg.package];

    ui.log(&#x27;info&#x27;, &#x27;Looking up `&#x27; + pkg.name + &#x27;`&#x27;);

    lookupPromises[pkg.package] = Promise.resolve(registry.load(pkg.registry).lookup(pkg.package));
    return lookupPromises[pkg.package];
  })
  .then(function(lookup) {
    if (lookup.notfound)
      throw &#x27;Repo `&#x27; + pkg.name + &#x27;` not found!&#x27;;

    if (!lookup.versions)
      throw &#x27;Invalid registry lookup response for %&#x27; + pkg.registry + &#x27;%&#x27;;

    lookups[pkg.package] = lookup.versions;

    return function(version) {
      var opts = {edge: edge, latestVersion: lookup.latest};
      var lookupObj = getVersionMatch(version, lookup.versions, opts);
      if (!lookupObj)
        return;

      return new PackageName(pkg.name + &#x27;@&#x27; + lookupObj.version, true);
    };
  }, function() {
    throw &#x27;Error looking up `&#x27; + pkg.name + &#x27;`.&#x27;;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function dl(name, repo, version) {
var pkg = new PackageName(repo);
var endpoint = registry.load(pkg.registry);
var vMatch, vMatchLookup;
var dlDir = path.resolve(loaderFilesCacheDir, name);

return endpoint.<span class="apidocCodeKeywordSpan">lookup</span>(pkg.package)
.then(function(lookup) {
  if (!(nodeSemver.validRange(version)))
    vMatch = version;
  else
    vMatch = Object.keys(lookup.versions)
    .filter(nodeSemver.valid)
    .sort(nodeSemver.compare).reverse()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.package.processDeps" id="apidoc.element.jspm.package.processDeps">
        function <span class="apidocSignatureSpan">jspm.package.</span>processDeps
        <span class="apidocSignatureSpan">(deps, registry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function processDeps(deps, registry) {
  var outdeps = {};
  if (!deps)
    return outdeps;
  Object.keys(deps).forEach(function(p) {
    var dep = deps[p];

    if (dep instanceof PackageName) {
      outdeps[p] = dep;
      return outdeps[p];
    }

    var outPackage;

    // jquery: github:components/jquery
    // jquery: jquery@1.5
    // -&#x3e; RHS is dep
    if (dep.indexOf(&#x27;:&#x27;) !== -1)
      outPackage = dep;

    else if (!registry)
      throw new TypeError(&#x27;Install of %&#x27; + p + &#x27;% to `&#x27; + dep + &#x27;` has no registry property provided.&#x27;);

    // jquery: components/jquery@1.5
    else if (dep.lastIndexOf(&#x27;@&#x27;) &#x3e; 0)
      outPackage = registry + &#x27;:&#x27; + dep;

    // jquery: 1.5
    else
      outPackage = registry + &#x27;:&#x27; + p + &#x27;@&#x27; + dep;

    outdeps[p] = new PackageName(outPackage, true);
  });
  return outdeps;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
else if (targets &#x26;&#x26; options.update)
  for (d in targets) {
    if (!existingTargets[d])
      throw &#x27;%&#x27; + d + &#x27;% is not an existing dependency to update.&#x27;;
    targets[d] = existingTargets[d];
  }

targets = pkg.<span class="apidocCodeKeywordSpan">processDeps</span>(targets, globalConfig.config.defaultRegistry);

return Promise.all(Object.keys(targets).map(function(name) {
  return install(name, targets[name], options);
}))
.then(function() {
  return saveInstall();
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.package.processPackage" id="apidoc.element.jspm.package.processPackage">
        function <span class="apidocSignatureSpan">jspm.package.</span>processPackage
        <span class="apidocSignatureSpan">(pkg, dir, pjson, postload, isCDN)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processPackage = function (pkg, dir, pjson, postload, isCDN) {
  // any package which takes longer than 10 seconds to process
  var timeout = setTimeout(function() {
    ui.log(&#x27;warn&#x27;, &#x27;It\&#x27;s taking a long time to process the dependencies of `&#x27; + pkg.exactName + &#x27;`.\n&#x27; +
      &#x27;This package may need an %ignore% property to indicate test or example folders for jspm to skip.\n&#x27;);
  }, 10000);
  var endpoint = registry.load(pjson.registry || pkg.registry);
  var deps;
  var buildErrors = [];
  var curDeps = [];

  return Promise.resolve()

  .then(function() {
    // now that we have the derived pjson, do the registry build
    if (endpoint.build)
      return Promise.resolve()
      .then(function() {
        curDeps = pjson.dependencies &#x26;&#x26; Object.keys(pjson.dependencies) || [];
        return endpoint.build(pjson, dir);
      })
      .catch(function() {
        throw &#x27;Error building package `&#x27; + pkg.name + &#x27;`.&#x27;;
      });
  })

  // apply build operations from the package.json
  .then(function(_buildErrors) {
    if (_buildErrors)
      buildErrors = buildErrors.concat(_buildErrors);

    // if we gained a new dependency, download it
    postload(getDepRanges(pjson));

    // don&#x27;t build in dependencies
    if (!isCDN) {
      deps = pjson.dependencies;
      delete pjson.dependencies;
    }
    else {
      deps = pjson.dependencies;
      pjson.dependencies = processDeps(pjson.dependencies, pjson.registry);
    }

    return build.buildPackage(dir, pjson, isCDN);
  })

  // save the final calculated package.json in place
  .then(function(_buildErrors) {
    if (_buildErrors)
      buildErrors = buildErrors.concat(_buildErrors);
    pjson.dependencies = deps;
  })
  .then(function() {
    // write build errors
    if (buildErrors.length)
      return asp(fs.writeFile)(path.resolve(dir, &#x27;.jspm.errors&#x27;), buildErrors.join(&#x27;\n\n&#x27;));
  })
  .then(function() {
    clearTimeout(timeout);
    return pjson;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  })
  // copy the files to the local cache folder
  .then(function() {
    return asp(ncp)(dir, linkDir);
  })
  // run the jspm operations on the folder to process it
  .then(function() {
    return package.<span class="apidocCodeKeywordSpan">processPackage</span>(pkg, linkDir, pjson, function() {});
  })
  .then(function() {
    return asp(fs.writeFile)(path.resolve(linkDir, &#x27;.jspm.json&#x27;), JSON.stringify(pjson, null, 2));
  });
})
.then(function(aborted) {
  if (!aborted)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.registry" id="apidoc.module.jspm.registry">module jspm.registry</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.registry.configure" id="apidoc.element.jspm.registry.configure">
        function <span class="apidocSignatureSpan">jspm.registry.</span>configure
        <span class="apidocSignatureSpan">(registry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (registry) {
  var registryConfig = globalConfig.config.registries[registry] || {},
      RegistryClass;

  if (!registryConfig.handler)
    throw &#x27;Registry %&#x27; + registry + &#x27;% not found.&#x27;;

  var handler = registryConfig.handler;
  delete registryConfig.handler;

  try {
    RegistryClass = require(handler);
  }
  catch(e) {
    throw &#x27;Registry handler `&#x27; + handler + &#x27;` not installed.&#x27;;
  }

  registryConfig.name = registry;
  registryConfig.strictSSL = globalConfig.config.strictSSL;

  return Promise.resolve(RegistryClass.configure &#x26;&#x26; RegistryClass.configure(registryConfig, ui) || registryConfig)
  .then(function(_config) {
    delete _config.name;
    delete _config.strictSSL;
    _config.handler = handler;
    globalConfig.config.registries[registry] = _config;
  })
  .then(function() {
    globalConfig.save();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          function checkConfigure(err) {
            if (err &#x26;&#x26; err.config &#x26;&#x26; !self.triedConfig) {
              // Place promise chain on existing instance, to block subsequent hooks.
              // Also print warning for only for first such error, if multiple in a batch
              if (!self.reconfigPromise_) {
ui.log(&#x27;warn&#x27;, err.message);

self.reconfigPromise_ = exports.<span class="apidocCodeKeywordSpan">configure</span>(registry)
.then(function() {
  // replace registered instance
  delete registryClasses[registry];
  var instance = exports.load(registry);
  instance.triedConfig = true;
  return instance;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.registry.create" id="apidoc.element.jspm.registry.create">
        function <span class="apidocSignatureSpan">jspm.registry.</span>create
        <span class="apidocSignatureSpan">(name, handler, override)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (name, handler, override) {

  // handle override prompts etc
  if (!override &#x26;&#x26; globalConfig.config.registries[name]) {
    if (globalConfig.config.registries[name].handler === handler)
      return ui.confirm(&#x27;Registry %&#x27; + name + &#x27;% already exists. Do you want to reconfigure it now?&#x27;)
      .then(function(configure) {
        if (configure)
          return Promise.resolve(exports.configure(name))
          .then(function() {
            ui.log(&#x27;ok&#x27;, &#x27;Registry %&#x27; + name + &#x27;% configured successfully.&#x27;);
            return false;
          });
        else
          return false;
      });
    else
      return ui.confirm(&#x27;Registry %&#x27; + name + &#x27;% already exists, but based on `&#x27; + globalConfig.config.registries[name].handler + &#x27;`.
Are you sure you want to override it?&#x27;)
      .then(function(override) {
        if (override)
          return Promise.resolve(exports.create(name, handler, true));
        return false;
      });
  }

  var registryConfig = globalConfig.config.registries[name] = globalConfig.config.registries[name] || {};
  registryConfig.handler = handler;

  // load the registry and configure it
  return exports.configure(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  delete cfg.baseURL;

this.config(cfg, true);

if (typeof _config == &#x27;object&#x27;)
  this.config(_config, true);
}
Builder.prototype = Object.<span class="apidocCodeKeywordSpan">create</span>(SystemJSBuilder.prototype);

// extend build functions with jspm 0.16 compatibility options
Builder.prototype.bundle = function(expressionOrTree, outFile, opts) {
if (outFile &#x26;&#x26; typeof outFile === &#x27;object&#x27;) {
  opts = outFile;
  outFile = undefined;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.registry.load" id="apidoc.element.jspm.registry.load">
        function <span class="apidocSignatureSpan">jspm.registry.</span>load
        <span class="apidocSignatureSpan">(registry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (registry) {
  if (registryClasses[registry])
    return registryClasses[registry];

  try {
    // ensure the tmpDir exists
    var tmpDir = path.resolve(config.HOME, &#x27;.jspm&#x27;, registry + &#x27;-cache&#x27;);
    if (!fs.existsSync(tmpDir))
      fs.mkdirSync(tmpDir);

    var options = dextend({
      timeouts: {
        lookup: 60,
        download: 300,
        build: 120
      },
      tmpDir: tmpDir,
      apiVersion: &#x27;1.6&#x27;
    }, globalConfig.config.registries[registry] || {});

    options.name = registry;
    if (globalConfig.config.strictSSL === false || globalConfig.config.strictSSL == &#x27;false&#x27;)
      options.strictSSL = false;

    if (!options.handler)
      throw &#x27;Registry %&#x27; + registry + &#x27;% not found.&#x27;;

    var RegistryClass = require(options.handler);
    var registryPackageJSON = require(options.handler + &#x27;/package.json&#x27;);
    var versionString = registryPackageJSON.name + &#x27;@&#x27; + registryPackageJSON.version.split(&#x27;.&#x27;).splice(0, 2).join(&#x27;.&#x27;);
    options.versionString = versionString;

    var registryInstance = registryClasses[registry] = new RegistryClass(options, ui);
    registryInstance.constructor = RegistryClass;

    var timeoutLookup = options.timeouts.lookup * 1000;
    var timeoutDownload = options.timeouts.download * 1000;
    var timeoutBuild = options.timeouts.build * 1000;

    registryInstance.versionString = registryInstance.versionString || versionString;

    var maxRetries = globalConfig.config.maxRetries || 3;

    // patch the calls to apply timeout and retry logic
    registryHooks.forEach(function(hook) {
      if (!registryInstance[hook])
        return;

      var runHook = registryInstance[hook];
      registryInstance[hook] = function() {
        var self = this;
        var args = arguments;
        var retries = 0;
        var timeout;
        if (hook == &#x27;download&#x27;)
          timeout = timeoutDownload;
        else if (hook == &#x27;build&#x27;)
          timeout = timeoutBuild;
        else
          timeout = timeoutLookup;

        return new Promise(function(resolve, reject) {

          function tryHook() {
            var active = true;

            var timer = setTimeout(function() {
              active = false;
              checkRetry();
            }, timeout);

            // in case registry is being reconfigured, chain on a promise
            // which delivers the registry to use, when it is ready
            (self.reconfigPromise_ || Promise.resolve(self))
            .then(function(endpoint) {
              self = endpoint;
              return runHook.apply(self, args);
            })
            .then(function(result) {
              clearTimeout(timer);
              if (active)
                resolve(result);
            }, function(err) {
              clearTimeout(timer);
              if (!active)
                return;
              active = false;
              return checkConfigure(err) || checkRetry(err);
            });
          }

<span class="apidocCodeCommentSpan">          /* When err.config is set, that indicates config credentials are somehow the cause.
           * Call the configure hook and reinstantiate the registry with new config */
</span>          function checkConfigure(err) {
            if (err &#x26;&#x26; err.config &#x26;&#x26; !self.triedConfig) {
              // Place promise chain on existing instance, to block subsequent hooks.
              // Also print warning for only for first such error, if multiple in a batch
              if (!self.reconfigPromise_) {
                ui.log(&#x27;warn&#x27;, err.message);

                self.reconfigPromise_ = exports.configure(registry)
                .then(function() {
                  // replace registered instance
                  delete registryClasses[registry];
                  var instance = exports.load(registry);
                  instance.triedConfig = true;
                  return instance;
                });
              }

              tryHook();
              return true;
            }
          }

          function checkRetry(err) {
            // don&#x27;t retry build or processPackageConfig
            if (hook === &#x27;build&#x27; || hook === &#x27;p ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.catch(function(e) {
  ui.log(&#x27;err&#x27;, e.stack || e);
  throw e;
});
};

exports.unbundle = function() {
return config.<span class="apidocCodeKeywordSpan">load</span>()
.then(function() {
  config.loader.bundles = {};
  config.loader.depCache = {};
  return config.save();
})
.then(function() {
  ui.log(&#x27;ok&#x27;, &#x27;Bundle configuration removed.&#x27;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.semver" id="apidoc.module.jspm.semver">module jspm.semver</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.semver.compare" id="apidoc.element.jspm.semver.compare">
        function <span class="apidocSignatureSpan">jspm.semver.</span>compare
        <span class="apidocSignatureSpan">(v1, v2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compare = function (v1, v2) {
  return semverCompareParsed(parseSemver(v1), parseSemver(v2));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
});

      // c. Forks against the existing tree are handled by upgrading the existing tree,
      //    at both primary and secondary levels, with the secondary fork potentially rolling back as well.
      resolveForks(installed, name, options.parent, resolution, function(forkVersion, forkRanges) {
if (options.latest &#x26;&#x26; semver.<span class="apidocCodeKeywordSpan">compare</span>(forkVersion, resolution.version) === 1
)
  return;

if (forkRanges.every(function(forkRange) {
  return semver.match(forkRange, resolution.version);
})) {
  consolidated = true;
  return resolution.version;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.semver.match" id="apidoc.element.jspm.semver.match">
        function <span class="apidocSignatureSpan">jspm.semver.</span>match
        <span class="apidocSignatureSpan">(range, version)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function match(range, version) {
  // supported range types:
  // 0.2, 1, ~1.2.3, ^1.2.3, ^0.4.3-alpha.1
  if (range === &#x27;&#x27; || range === &#x27;*&#x27;)
    return true;
  return matchParsed(parseRange(range), parseSemver(version));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
})
.then(function() {
  logBuild(path.relative(process.cwd(), fileName), opts);
})
.catch(function(e) {
  // catch sfx globals error to give a better error message
  if (e.toString().indexOf(&#x27;globalDeps option&#x27;) != -1) {
    var module = e.toString().<span class="apidocCodeKeywordSpan">match</span>(/dependency &#x22;([^&#x22;]+)&#x22;/);
    ui.log(&#x27;err&#x27;, &#x27;SFX exclusion &#x22;&#x27; + module[1] + &#x27;&#x22; needs a reference.\nEither output an SFX
 module format like %--format amd% or map the module to an environment global via %--globals &#x22;{\&#x27;test.js\&#x27;: \&#x27;test\&#x27;}&#x22;%.&#x27;);
    throw &#x27;SFX Bundle input error&#x27;;
  }

  ui.log(&#x27;err&#x27;, e.stack || e);
  throw e;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.semver.matchUnstable" id="apidoc.element.jspm.semver.matchUnstable">
        function <span class="apidocSignatureSpan">jspm.semver.</span>matchUnstable
        <span class="apidocSignatureSpan">(range, version)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function match(range, version) {
  // supported range types:
  // 0.2, 1, ~1.2.3, ^1.2.3, ^0.4.3-alpha.1
  if (range === &#x27;&#x27; || range === &#x27;*&#x27;)
    return true;
  return matchParsed(parseRange(range), parseSemver(version), true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.ui" id="apidoc.module.jspm.ui">module jspm.ui</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.ui.confirm" id="apidoc.element.jspm.ui.confirm">
        function <span class="apidocSignatureSpan">jspm.ui.</span>confirm
        <span class="apidocSignatureSpan">(msg, def)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">confirm = function (msg, def) {
  if (useDefaults) {
    if (def !== true &#x26;&#x26; def !== false)
      def = true;
    process.stdout.write(format.q(msg) + (def ? &#x27;Yes&#x27; : &#x27;No&#x27;) + &#x27;\n&#x27;);
    return Promise.resolve(def);
  }

  if (apiResolver)
    return new Promise(function(resolve) {
      apiResolver.emit(&#x27;prompt&#x27;, {
        type: &#x27;confirm&#x27;,
        message: msg,
        default: def
      }, function(answer) {
        resolve(answer);
      });
    });

  var defText = &#x27;y/n&#x27;;
  if (def === true)
    defText = &#x27;yes&#x27;;
  else if (def === false)
    defText = &#x27;no&#x27;;
  else
    def = undefined;

  var p = cli.input(msg, defText);
  return p.then(function(reply) {
    if (reply.match(/\b(no|n)\b/i))
      return false;
    else if (reply.match(/\b(yes|y\b)/i))
      return true;
    else if (def !== undefined)
      return def;
    else
      return confirm(msg, def);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return (loadPromise = Promise.resolve()
.then(function() {

  if (process.env.globalJspm === &#x27;true&#x27;)
    ui.log(&#x27;warn&#x27;, &#x27;Running jspm globally, it is advisable to locally install jspm via %npm install jspm --save-dev
%.&#x27;);

  if (!process.env.jspmConfigPath)
    return ui.<span class="apidocCodeKeywordSpan">confirm</span>(&#x27;Package.json file does not exist, create it?&#x27;, true)
    .then(function(create) {
      if (!create)
        throw &#x27;Operation aborted.&#x27;;
    });
})
.then(function() {
  config.pjsonPath = process.env.jspmConfigPath || path.resolve(process.cwd(), &#x27;package.json&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.ui.input" id="apidoc.element.jspm.ui.input">
        function <span class="apidocSignatureSpan">jspm.ui.</span>input
        <span class="apidocSignatureSpan">(msg, def, disableOutput, queue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">input = function (msg, def, disableOutput, queue) {
  if (useDefaults) {
    process.stdout.write(format.q(msg) + def + &#x27;\n&#x27;);
    return Promise.resolve(def);
  }

  if (apiResolver)
    return new Promise(function(resolve) {
      apiResolver.emit(&#x27;prompt&#x27;, {
        type: &#x27;input&#x27;,
        message: msg,
        default: def
      }, function(answer) {
        resolve(answer.input);
      });
    });

  if (arguments.length === 2)
    disableOutput = false;

  return new Promise(function(resolve, reject) {
    if (!logging &#x26;&#x26; !queue)
      return inputQueue.push({
        args: [msg, def, disableOutput, true],
        resolve: resolve,
        reject: reject
      });

    if (logging &#x26;&#x26; logged)
      process.stdout.write(&#x27;\n&#x27;);
    logging = false;
    process.stdout.write(format.q(msg, def));
    process.stdin.resume();
    process.stdin.setEncoding(&#x27;utf8&#x27;);
    if (disableOutput &#x26;&#x26; process.stdin.isTTY)
      process.stdin.setRawMode(disableOutput);
    var inputVal = &#x27;&#x27;;
    process.stdin.on(&#x27;data&#x27;, function(chunk) {
      var lastChar = chunk.substr(chunk.length - 1, 1);
      if (lastChar === &#x27;\n&#x27; || lastChar === &#x27;\r&#x27; || lastChar === &#x27;\u0004&#x27;) {
        if (disableOutput &#x26;&#x26; process.stdin.isTTY)
          process.stdin.setRawMode(false);
        process.stdin.pause();
        process.stdin.removeAllListeners(&#x27;data&#x27;);
        inputVal += chunk.substr(0, chunk.length - 1);

        if (disableOutput)
          process.stdout.write(&#x27;\n&#x27;);

        // bump the input queue
        var next = inputQueue.shift();
        if (next)
          cli.input.apply(null, next.args).then(next.resolve, next.reject);
        else {
          process.stdout.write(logBuffer);
          process.stderr.write(errBuffer);
          logBuffer = &#x27;&#x27;;
          errBuffer = &#x27;&#x27;;
          logging = true;
          logged = false;
        }

        resolve(inputVal.trim() || def);
      }
      inputVal += chunk;
    });

  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (config.map &#x26;&#x26; hasProperties(config.map)) {

    var depMap;

    return Promise.resolve()
    .then(function() {
      if (!config.name)
        return ui.<span class="apidocCodeKeywordSpan">input</span>(&#x27;Enter project name to use contextual mappings&#x27;, &#
x27;app&#x27;)
        .then(function(name) {
config.name = name;

// if the lib directory is not in package.json, and we&#x27;ve given a name
// then the new lib default is the name not &#x27;lib&#x27;
if (!pjsonCache.directories || !pjsonCache.directories.lib)
  config.lib = path.resolve(config.dir, config.name);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.ui.log" id="apidoc.element.jspm.ui.log">
        function <span class="apidocSignatureSpan">jspm.ui.</span>log
        <span class="apidocSignatureSpan">(type, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function (type, msg) {
  if (apiResolver)
    return apiResolver.emit(&#x27;log&#x27;, type, msg);

  logged = true;

  if (arguments.length === 1) {
    msg = type;
    type = null;
  }

  msg = msg || &#x27;&#x27;;

  if (type)
    msg = format[type](msg.toString());

  var logLevel = logTypes.indexOf(type);
  if (logLevel == -1)
    logLevel = 3;
  if (logLevel &#x3c;= ui.logLevel) {
    if (logging) {
      if (type != &#x27;err&#x27;)
        console.log(msg);
      else
        console.error(msg);
    }
    else {
      if (type != &#x27;err&#x27;)
        logBuffer += msg + &#x27;\n&#x27;;
      else
        errBuffer += msg + &#x27;\n&#x27;;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports.Builder = Builder;

exports.depCache = function(expression) {
var systemBuilder = new Builder();

expression = expression || config.loader.main;

ui.<span class="apidocCodeKeywordSpan">log</span>(&#x27;info&#x27;, &#x27;Injecting the traced dependency tree for `&#x27; + expression
 + &#x27;`...&#x27;);

return systemBuilder.trace(expression)
.then(function(tree) {
  logTree(tree);
  var depCache = config.loader.depCache || {};
  extend(depCache, systemBuilder.getDepCache(tree));
  config.loader.depCache = depCache;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.ui.setLogLevel" id="apidoc.element.jspm.ui.setLogLevel">
        function <span class="apidocSignatureSpan">jspm.ui.</span>setLogLevel
        <span class="apidocSignatureSpan">(level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setLogLevel = function (level) {
  if (!level)
    return;

  var levelIndex = logTypes.indexOf(level);

  if (levelIndex == -1)
    ui.log(&#x27;warn&#x27;, &#x27;Unknown log level: &#x27; + level);
  else
    ui.logLevel = levelIndex;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.ui.setResolver" id="apidoc.element.jspm.ui.setResolver">
        function <span class="apidocSignatureSpan">jspm.ui.</span>setResolver
        <span class="apidocSignatureSpan">(resolver)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setResolver = function (resolver) {
  apiResolver = resolver;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.ui.useDefaults" id="apidoc.element.jspm.ui.useDefaults">
        function <span class="apidocSignatureSpan">jspm.ui.</span>useDefaults
        <span class="apidocSignatureSpan">(_useDefaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">useDefaults = function (_useDefaults) {
  if (_useDefaults === undefined)
    _useDefaults = true;
  useDefaults = _useDefaults;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
