<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/jspm/jspm">jspm (v0.16.53)</a>
</h1>
<h4>Registry and format agnostic JavaScript package manager</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm">module jspm</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.Builder">
            function <span class="apidocSignatureSpan">jspm.</span>Builder
            <span class="apidocSignatureSpan">(_config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.Loader">
            function <span class="apidocSignatureSpan">jspm.</span>Loader
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.bundle">
            function <span class="apidocSignatureSpan">jspm.</span>bundle
            <span class="apidocSignatureSpan">(expression, fileName, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.bundleSFX">
            function <span class="apidocSignatureSpan">jspm.</span>bundleSFX
            <span class="apidocSignatureSpan">(expression, fileName, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.dlLoader">
            function <span class="apidocSignatureSpan">jspm.</span>dlLoader
            <span class="apidocSignatureSpan">(transpiler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.import">
            function <span class="apidocSignatureSpan">jspm.</span>import
            <span class="apidocSignatureSpan">(name, parentName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.install">
            function <span class="apidocSignatureSpan">jspm.</span>install
            <span class="apidocSignatureSpan">(name, target, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.loader">
            function <span class="apidocSignatureSpan">jspm.</span>loader
            <span class="apidocSignatureSpan">(fileName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.normalize">
            function <span class="apidocSignatureSpan">jspm.</span>normalize
            <span class="apidocSignatureSpan">(name, parentName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package_name">
            function <span class="apidocSignatureSpan">jspm.</span>package_name
            <span class="apidocSignatureSpan">(name, escape)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.promptDefaults">
            function <span class="apidocSignatureSpan">jspm.</span>promptDefaults
            <span class="apidocSignatureSpan">(_useDefaults)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.setPackagePath">
            function <span class="apidocSignatureSpan">jspm.</span>setPackagePath
            <span class="apidocSignatureSpan">(packagePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.unbundle">
            function <span class="apidocSignatureSpan">jspm.</span>unbundle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.uninstall">
            function <span class="apidocSignatureSpan">jspm.</span>uninstall
            <span class="apidocSignatureSpan">(names)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jspm.</span>_eventsCount</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>Builder.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>_events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>common</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>core</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>domain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>global_config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>link</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>loader.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>package</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>package_name.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>registry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>semver</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>ui</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.</span>utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jspm.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.Builder">module jspm.Builder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.Builder.Builder">
            function <span class="apidocSignatureSpan">jspm.</span>Builder
            <span class="apidocSignatureSpan">(_config)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.Builder.prototype">module jspm.Builder.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.Builder.prototype.buildStatic">
            function <span class="apidocSignatureSpan">jspm.Builder.prototype.</span>buildStatic
            <span class="apidocSignatureSpan">(expressionOrTree, outFile, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.Builder.prototype.bundle">
            function <span class="apidocSignatureSpan">jspm.Builder.prototype.</span>bundle
            <span class="apidocSignatureSpan">(expressionOrTree, outFile, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.bundle">module jspm.bundle</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.bundle.bundle">
            function <span class="apidocSignatureSpan">jspm.</span>bundle
            <span class="apidocSignatureSpan">(moduleExpression, fileName, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.bundle.Builder">
            function <span class="apidocSignatureSpan">jspm.bundle.</span>Builder
            <span class="apidocSignatureSpan">(_config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.bundle.bundleSFX">
            function <span class="apidocSignatureSpan">jspm.bundle.</span>bundleSFX
            <span class="apidocSignatureSpan">(expression, fileName, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.bundle.depCache">
            function <span class="apidocSignatureSpan">jspm.bundle.</span>depCache
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.bundle.unbundle">
            function <span class="apidocSignatureSpan">jspm.bundle.</span>unbundle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.common">module jspm.common</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.common.alphabetize">
            function <span class="apidocSignatureSpan">jspm.common.</span>alphabetize
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.common.cascadeDelete">
            function <span class="apidocSignatureSpan">jspm.common.</span>cascadeDelete
            <span class="apidocSignatureSpan">(dir, stopDir)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.common.dextend">
            function <span class="apidocSignatureSpan">jspm.common.</span>dextend
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.common.dprepend">
            function <span class="apidocSignatureSpan">jspm.common.</span>dprepend
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.common.extend">
            function <span class="apidocSignatureSpan">jspm.common.</span>extend
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.common.fromFileURL">
            function <span class="apidocSignatureSpan">jspm.common.</span>fromFileURL
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.common.getRedirectContents">
            function <span class="apidocSignatureSpan">jspm.common.</span>getRedirectContents
            <span class="apidocSignatureSpan">(format, main)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.common.hasProperties">
            function <span class="apidocSignatureSpan">jspm.common.</span>hasProperties
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.common.readJSON">
            function <span class="apidocSignatureSpan">jspm.common.</span>readJSON
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.common.readJSONSync">
            function <span class="apidocSignatureSpan">jspm.common.</span>readJSONSync
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.common.stringify">
            function <span class="apidocSignatureSpan">jspm.common.</span>stringify
            <span class="apidocSignatureSpan">(subject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.common.toFileURL">
            function <span class="apidocSignatureSpan">jspm.common.</span>toFileURL
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.config">module jspm.config</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">jspm.config.</span>loaded</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.config.derivePackageConfig">
            function <span class="apidocSignatureSpan">jspm.config.</span>derivePackageConfig
            <span class="apidocSignatureSpan">(pjson, override)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.config.load">
            function <span class="apidocSignatureSpan">jspm.config.</span>load
            <span class="apidocSignatureSpan">(prompts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.config.loadSync">
            function <span class="apidocSignatureSpan">jspm.config.</span>loadSync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.config.save">
            function <span class="apidocSignatureSpan">jspm.config.</span>save
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.config.</span>loader</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.config.</span>pjson</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jspm.config.</span>HOME</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jspm.config.</span>newLine</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jspm.config.</span>tab</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.core">module jspm.core</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.core.build">
            function <span class="apidocSignatureSpan">jspm.core.</span>build
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.core.cacheClear">
            function <span class="apidocSignatureSpan">jspm.core.</span>cacheClear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.core.checkDlLoader">
            function <span class="apidocSignatureSpan">jspm.core.</span>checkDlLoader
            <span class="apidocSignatureSpan">(transpilerName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.core.dlLoader">
            function <span class="apidocSignatureSpan">jspm.core.</span>dlLoader
            <span class="apidocSignatureSpan">(transpilerName, unminified, edge, latest)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.core.dlTranspiler">
            function <span class="apidocSignatureSpan">jspm.core.</span>dlTranspiler
            <span class="apidocSignatureSpan">(transpilerName, update)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.core.init">
            function <span class="apidocSignatureSpan">jspm.core.</span>init
            <span class="apidocSignatureSpan">(basePath, ask)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.core.run">
            function <span class="apidocSignatureSpan">jspm.core.</span>run
            <span class="apidocSignatureSpan">(moduleName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.core.setMode">
            function <span class="apidocSignatureSpan">jspm.core.</span>setMode
            <span class="apidocSignatureSpan">(modes)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.global_config">module jspm.global_config</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.global_config.save">
            function <span class="apidocSignatureSpan">jspm.global_config.</span>save
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.global_config.set">
            function <span class="apidocSignatureSpan">jspm.global_config.</span>set
            <span class="apidocSignatureSpan">(name, val)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.global_config.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.global_config.</span>registries</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.install">module jspm.install</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.install.install">
            function <span class="apidocSignatureSpan">jspm.</span>install
            <span class="apidocSignatureSpan">(targets, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.install.clean">
            function <span class="apidocSignatureSpan">jspm.install.</span>clean
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.install.resolveOnly">
            function <span class="apidocSignatureSpan">jspm.install.</span>resolveOnly
            <span class="apidocSignatureSpan">(pkg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.install.showInstallGraph">
            function <span class="apidocSignatureSpan">jspm.install.</span>showInstallGraph
            <span class="apidocSignatureSpan">(pkg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.install.showVersions">
            function <span class="apidocSignatureSpan">jspm.install.</span>showVersions
            <span class="apidocSignatureSpan">(forks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.install.uninstall">
            function <span class="apidocSignatureSpan">jspm.install.</span>uninstall
            <span class="apidocSignatureSpan">(names)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.link">module jspm.link</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.link.link">
            function <span class="apidocSignatureSpan">jspm.</span>link
            <span class="apidocSignatureSpan">(name, dir, force)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.link.lookup">
            function <span class="apidocSignatureSpan">jspm.link.</span>lookup
            <span class="apidocSignatureSpan">(pkg, edge)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.link.symlink">
            function <span class="apidocSignatureSpan">jspm.link.</span>symlink
            <span class="apidocSignatureSpan">(pkg, downloadDeps)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.loader">module jspm.loader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.loader.loader">
            function <span class="apidocSignatureSpan">jspm.</span>loader
            <span class="apidocSignatureSpan">(fileName)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.loader.prototype">module jspm.loader.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.loader.prototype.ensureRegistry">
            function <span class="apidocSignatureSpan">jspm.loader.prototype.</span>ensureRegistry
            <span class="apidocSignatureSpan">(registryName, remote)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.loader.prototype.getConfig">
            function <span class="apidocSignatureSpan">jspm.loader.prototype.</span>getConfig
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.loader.prototype.read">
            function <span class="apidocSignatureSpan">jspm.loader.prototype.</span>read
            <span class="apidocSignatureSpan">(prompts, sync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.loader.prototype.write">
            function <span class="apidocSignatureSpan">jspm.loader.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.package">module jspm.package</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package.createMain">
            function <span class="apidocSignatureSpan">jspm.package.</span>createMain
            <span class="apidocSignatureSpan">(pkg, pjson, downloadDir)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package.derivePackageConfig">
            function <span class="apidocSignatureSpan">jspm.package.</span>derivePackageConfig
            <span class="apidocSignatureSpan">(pkg, pjson, override)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package.download">
            function <span class="apidocSignatureSpan">jspm.package.</span>download
            <span class="apidocSignatureSpan">(pkg, options, installDeps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package.getVersionMatch">
            function <span class="apidocSignatureSpan">jspm.package.</span>getVersionMatch
            <span class="apidocSignatureSpan">(pkgVersion, versions, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package.inject">
            function <span class="apidocSignatureSpan">jspm.package.</span>inject
            <span class="apidocSignatureSpan">(pkg, depLoad)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package.locate">
            function <span class="apidocSignatureSpan">jspm.package.</span>locate
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package.lookup">
            function <span class="apidocSignatureSpan">jspm.package.</span>lookup
            <span class="apidocSignatureSpan">(pkg, edge)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package.processDeps">
            function <span class="apidocSignatureSpan">jspm.package.</span>processDeps
            <span class="apidocSignatureSpan">(deps, registry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package.processPackage">
            function <span class="apidocSignatureSpan">jspm.package.</span>processPackage
            <span class="apidocSignatureSpan">(pkg, dir, pjson, postload, isCDN)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.package.</span>registryCache</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.package_name">module jspm.package_name</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package_name.package_name">
            function <span class="apidocSignatureSpan">jspm.</span>package_name
            <span class="apidocSignatureSpan">(name, escape)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.package_name.prototype">module jspm.package_name.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package_name.prototype.copy">
            function <span class="apidocSignatureSpan">jspm.package_name.prototype.</span>copy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package_name.prototype.getPath">
            function <span class="apidocSignatureSpan">jspm.package_name.prototype.</span>getPath
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package_name.prototype.setRegistry">
            function <span class="apidocSignatureSpan">jspm.package_name.prototype.</span>setRegistry
            <span class="apidocSignatureSpan">(registry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package_name.prototype.setVersion">
            function <span class="apidocSignatureSpan">jspm.package_name.prototype.</span>setVersion
            <span class="apidocSignatureSpan">(version)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.package_name.prototype.write">
            function <span class="apidocSignatureSpan">jspm.package_name.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.registry">module jspm.registry</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.registry.configure">
            function <span class="apidocSignatureSpan">jspm.registry.</span>configure
            <span class="apidocSignatureSpan">(registry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.registry.create">
            function <span class="apidocSignatureSpan">jspm.registry.</span>create
            <span class="apidocSignatureSpan">(name, handler, override)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.registry.load">
            function <span class="apidocSignatureSpan">jspm.registry.</span>load
            <span class="apidocSignatureSpan">(registry)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.semver">module jspm.semver</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.semver.compare">
            function <span class="apidocSignatureSpan">jspm.semver.</span>compare
            <span class="apidocSignatureSpan">(v1, v2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.semver.match">
            function <span class="apidocSignatureSpan">jspm.semver.</span>match
            <span class="apidocSignatureSpan">(range, version)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.semver.matchUnstable">
            function <span class="apidocSignatureSpan">jspm.semver.</span>matchUnstable
            <span class="apidocSignatureSpan">(range, version)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.semver.</span>semverRegEx</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.ui">module jspm.ui</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.ui.confirm">
            function <span class="apidocSignatureSpan">jspm.ui.</span>confirm
            <span class="apidocSignatureSpan">(msg, def)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.ui.input">
            function <span class="apidocSignatureSpan">jspm.ui.</span>input
            <span class="apidocSignatureSpan">(msg, def, disableOutput, queue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.ui.log">
            function <span class="apidocSignatureSpan">jspm.ui.</span>log
            <span class="apidocSignatureSpan">(type, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.ui.setLogLevel">
            function <span class="apidocSignatureSpan">jspm.ui.</span>setLogLevel
            <span class="apidocSignatureSpan">(level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.ui.setResolver">
            function <span class="apidocSignatureSpan">jspm.ui.</span>setResolver
            <span class="apidocSignatureSpan">(resolver)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.ui.useDefaults">
            function <span class="apidocSignatureSpan">jspm.ui.</span>useDefaults
            <span class="apidocSignatureSpan">(_useDefaults)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jspm.ui.</span>logLevel</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jspm.ui.</span>format</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jspm.utils">module jspm.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jspm.utils.extractObj">
            function <span class="apidocSignatureSpan">jspm.utils.</span>extractObj
            <span class="apidocSignatureSpan">(obj, host)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm" id="apidoc.module.jspm">module jspm</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.Builder" id="apidoc.element.jspm.Builder">
        function <span class="apidocSignatureSpan">jspm.</span>Builder
        <span class="apidocSignatureSpan">(_config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Builder(_config) {
  config.loadSync();
  SystemJSBuilder.call(this, toFileURL(config.pjson.baseURL));

  var cfg = config.loader.getConfig();

  if (cfg.depCache)
    delete cfg.depCache;
  if (cfg.bundles)
    delete cfg.bundles;
  if (cfg.baseURL)
    delete cfg.baseURL;

  this.config(cfg, true);

  if (typeof _config == 'object')
    this.config(_config, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.Loader" id="apidoc.element.jspm.Loader">
        function <span class="apidocSignatureSpan">jspm.</span>Loader
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Loader = function () {
  config.loadSync();

  var cfg = config.loader.getConfig();
  cfg.baseURL = toFileURL(config.pjson.baseURL);

  var loader = new SystemJSLoader();
  loader.config(cfg);

  return loader;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.bundle" id="apidoc.element.jspm.bundle">
        function <span class="apidocSignatureSpan">jspm.</span>bundle
        <span class="apidocSignatureSpan">(expression, fileName, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bundle = function (expression, fileName, options) {
  return bundle.bundle(expression, fileName, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.then(function() {
  ui.log('info', 'Building the bundle tree for `' + moduleExpression + '`...');

  return systemBuilder.trace(moduleExpression);
})
.then(function(buildTree) {
  logTree(buildTree);
  return systemBuilder.<span class="apidocCodeKeywordSpan">bundle</span>(buildTree, fileName, opts);
})
.then(function(output) {
  if (opts.injectConfig)
    ui.log('ok', '`' + output.bundleName + '` added to config bundles.');

  logBuild(path.relative(process.cwd(), fileName), opts);
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.bundleSFX" id="apidoc.element.jspm.bundleSFX">
        function <span class="apidocSignatureSpan">jspm.</span>bundleSFX
        <span class="apidocSignatureSpan">(expression, fileName, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bundleSFX = function (expression, fileName, options) {
  return bundle.bundleSFX(expression, fileName, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.dlLoader" id="apidoc.element.jspm.dlLoader">
        function <span class="apidocSignatureSpan">jspm.</span>dlLoader
        <span class="apidocSignatureSpan">(transpiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dlLoader = function (transpiler) {
  return core.checkDlLoader(transpiler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  core.init(options.args[1], options.prompts);
  break;

case 'dl-loader':
  options = readOptions(args, ['source', 'latest', 'edge', 'yes', 'traceur', &amp;#
x27;babel', 'typescript']);
  if (options.yes)
    ui.useDefaults();
  core.<span class="apidocCodeKeywordSpan">dlLoader</span>(options.args[1] || options.traceur &amp;&amp; 'traceur' ||
options.babel &amp;&amp; 'babel' || options.typescript &amp;&amp; 'typescript', options.source, options.
edge, options.latest);
  break;

case 'setmode':
  options = readOptions(args, ['yes']);
  if (options.yes)
    ui.useDefaults();
  core.setMode(args.splice(1))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.import" id="apidoc.element.jspm.import">
        function <span class="apidocSignatureSpan">jspm.</span>import
        <span class="apidocSignatureSpan">(name, parentName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">import = function (name, parentName) {
  apiLoader = apiLoader || new API.Loader();
  return apiLoader.import(name, parentName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return config.load()
  .then(function() {
    var cfg = config.loader.getConfig();
    delete cfg.bundles;
    cfg.baseURL = toFileURL(config.pjson.baseURL);
    System.config(cfg);

    return System.<span class="apidocCodeKeywordSpan">import</span>(moduleName);
  })
  .catch(function(e) {
    ui.log('err', e.stack || e);
  });
};

exports.build = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.install" id="apidoc.element.jspm.install">
        function <span class="apidocSignatureSpan">jspm.</span>install
        <span class="apidocSignatureSpan">(name, target, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">install = function (name, target, options) {
  return install.install(name, target, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ui.useDefaults();

// jspm install with no arguments is locked
if (!depMap &amp;&amp; !doUpdate)
  options.lock = true;

// no install package -&gt; install from package.json dependencies
(depMap ? install.<span class="apidocCodeKeywordSpan">install</span>(depMap, options) : install.install(true, options))
.then(function() {
  return core.checkDlLoader();
})
.then(function() {
  return core.setMode(inject ? 'remote' : 'local');
})
.then(function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.loader" id="apidoc.element.jspm.loader">
        function <span class="apidocSignatureSpan">jspm.</span>loader
        <span class="apidocSignatureSpan">(fileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Config(fileName) {
  this.__fileName = fileName;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.normalize" id="apidoc.element.jspm.normalize">
        function <span class="apidocSignatureSpan">jspm.</span>normalize
        <span class="apidocSignatureSpan">(name, parentName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalize = function (name, parentName) {
  apiLoader = apiLoader || new API.Loader();
  return apiLoader.normalize(name, parentName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.package_name" id="apidoc.element.jspm.package_name">
        function <span class="apidocSignatureSpan">jspm.</span>package_name
        <span class="apidocSignatureSpan">(name, escape)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Package(name, escape) {
  this.exactName = name;

  if (name.indexOf(':') !== -1)
    this.registry = name.split(':')[0];

  var pkg = this.registry ? name.substr(this.registry.length + 1) : name;

  var versionIndex = pkg.lastIndexOf('@');
  var version = '';

  if (versionIndex !== -1 &amp;&amp; versionIndex !== 0) {
    version = pkg.substr(versionIndex + 1);
    pkg = pkg.substr(0, versionIndex);
  }

  if (escape &amp;&amp; version)
    version = version.replace(/[\/%]/g, function(symbol) {
      return encodeURIComponent(symbol);
    });

  this.package = pkg;

  this.name = (this.registry ? this.registry + ':' : '') + this.package;

  this.setVersion(version);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.promptDefaults" id="apidoc.element.jspm.promptDefaults">
        function <span class="apidocSignatureSpan">jspm.</span>promptDefaults
        <span class="apidocSignatureSpan">(_useDefaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">promptDefaults = function (_useDefaults) {
  ui.useDefaults(_useDefaults);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.setPackagePath" id="apidoc.element.jspm.setPackagePath">
        function <span class="apidocSignatureSpan">jspm.</span>setPackagePath
        <span class="apidocSignatureSpan">(packagePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setPackagePath = function (packagePath) {
  if (config.loaded &amp;&amp; process.env.jspmConfigPath !== path.resolve(packagePath, 'package.json'))
    throw new Error('Configuration has already been loaded. Call setPackagePath before using other APIs.');
  process.env.jspmConfigPath = path.resolve(packagePath, 'package.json');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.unbundle" id="apidoc.element.jspm.unbundle">
        function <span class="apidocSignatureSpan">jspm.</span>unbundle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbundle = function () {
  return bundle.unbundle();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    .catch(function() {
      process.exit(1);
    });
  }
  break;

case 'unbundle':
  bundle.<span class="apidocCodeKeywordSpan">unbundle</span>()
  .catch(function(e) {
    ui.log('err', e.stack || e);
    process.exit(1);
  });
  break;

case 'build':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.uninstall" id="apidoc.element.jspm.uninstall">
        function <span class="apidocSignatureSpan">jspm.</span>uninstall
        <span class="apidocSignatureSpan">(names)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uninstall = function (names) {
  return install.uninstall(names);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    case 'remove':
    case 'uninstall':
options = readOptions(args, ['yes']);

if (options.yes)
  ui.useDefaults();

install.<span class="apidocCodeKeywordSpan">uninstall</span>(options.args.splice(1))
.then(function() {
  ui.log('');
  ui.log('ok', 'Uninstall complete.');
}, function(err) {
  ui.log('err', err.stack || err);
  ui.log('warn', 'Uninstall changes not saved.');
  process.exit(1);
...</pre></li>
    </ul>




































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.Builder" id="apidoc.module.jspm.Builder">module jspm.Builder</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.Builder.Builder" id="apidoc.element.jspm.Builder.Builder">
        function <span class="apidocSignatureSpan">jspm.</span>Builder
        <span class="apidocSignatureSpan">(_config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Builder(_config) {
  config.loadSync();
  SystemJSBuilder.call(this, toFileURL(config.pjson.baseURL));

  var cfg = config.loader.getConfig();

  if (cfg.depCache)
    delete cfg.depCache;
  if (cfg.bundles)
    delete cfg.bundles;
  if (cfg.baseURL)
    delete cfg.baseURL;

  this.config(cfg, true);

  if (typeof _config == 'object')
    this.config(_config, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.Builder.prototype" id="apidoc.module.jspm.Builder.prototype">module jspm.Builder.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.Builder.prototype.buildStatic" id="apidoc.element.jspm.Builder.prototype.buildStatic">
        function <span class="apidocSignatureSpan">jspm.Builder.prototype.</span>buildStatic
        <span class="apidocSignatureSpan">(expressionOrTree, outFile, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildStatic = function (expressionOrTree, outFile, opts) {
  if (outFile &amp;&amp; typeof outFile === 'object') {
    opts = outFile;
    outFile = undefined;
  }

  opts = opts || {};

  if (outFile)
    opts.outFile = outFile;

  if (!('format' in opts))
    opts.format = 'global';

  if (!('lowResSourceMaps' in opts))
    opts.lowResSourceMaps = true;

  return SystemJSBuilder.prototype.buildStatic.call(this, expressionOrTree, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return removeExistingSourceMap(fileName);
})
.then(function() {
  ui.log('info', 'Building the single-file sfx bundle for `' + expression + '`...');

  opts.format = opts.format || 'global';

  return systemBuilder.<span class="apidocCodeKeywordSpan">buildStatic</span>(expression, fileName, opts);
})
.then(function() {
  logBuild(path.relative(process.cwd(), fileName), opts);
})
.catch(function(e) {
  // catch sfx globals error to give a better error message
  if (e.toString().indexOf('globalDeps option') != -1) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.Builder.prototype.bundle" id="apidoc.element.jspm.Builder.prototype.bundle">
        function <span class="apidocSignatureSpan">jspm.Builder.prototype.</span>bundle
        <span class="apidocSignatureSpan">(expressionOrTree, outFile, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bundle = function (expressionOrTree, outFile, opts) {
  if (outFile &amp;&amp; typeof outFile === 'object') {
    opts = outFile;
    outFile = undefined;
  }

  opts = opts || {};

  if (outFile)
    opts.outFile = outFile;

  if (!('normalize' in opts))
    opts.normalize = true;

  if (!('lowResSourceMaps' in opts))
    opts.lowResSourceMaps = true;

  var self = this;

  return SystemJSBuilder.prototype.bundle.call(this, expressionOrTree, opts)
  .then(function(output) {

    // Add the bundle to config if the inject flag was given
    if (opts.injectConfig &amp;&amp; opts.outFile) {
      // NB deprecate
      output.bundleName = output.bundleName || self.getCanonicalName(toFileURL(path.resolve(opts.outFile)));
      var bundleName = output.bundleName;

      if (!config.loader.bundles)
        config.loader.bundles = {};

      config.loader.bundles[bundleName] = output.modules;
      return config.save()
      .then(function() {
        return output;
      });
    }

    return output;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.then(function() {
  ui.log('info', 'Building the bundle tree for `' + moduleExpression + '`...');

  return systemBuilder.trace(moduleExpression);
})
.then(function(buildTree) {
  logTree(buildTree);
  return systemBuilder.<span class="apidocCodeKeywordSpan">bundle</span>(buildTree, fileName, opts);
})
.then(function(output) {
  if (opts.injectConfig)
    ui.log('ok', '`' + output.bundleName + '` added to config bundles.');

  logBuild(path.relative(process.cwd(), fileName), opts);
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.bundle" id="apidoc.module.jspm.bundle">module jspm.bundle</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.bundle.bundle" id="apidoc.element.jspm.bundle.bundle">
        function <span class="apidocSignatureSpan">jspm.</span>bundle
        <span class="apidocSignatureSpan">(moduleExpression, fileName, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bundle = function (moduleExpression, fileName, opts) {

  var systemBuilder = new Builder();

  opts = opts || {};

  opts.normalize = true;

  fileName = fileName || path.resolve(config.pjson.baseURL, 'build.js');

  return Promise.resolve()
  .then(function() {

    if (!opts.sourceMaps)
      return removeExistingSourceMap(fileName);
  })
  .then(function() {
    ui.log('info', 'Building the bundle tree for `' + moduleExpression + '`...');

    return systemBuilder.trace(moduleExpression);
  })
  .then(function(buildTree) {
    logTree(buildTree);
    return systemBuilder.bundle(buildTree, fileName, opts);
  })
  .then(function(output) {
    if (opts.injectConfig)
      ui.log('ok', '`' + output.bundleName + '` added to config bundles.');

    logBuild(path.relative(process.cwd(), fileName), opts);
  })
  .catch(function(e) {
    ui.log('err', e.stack || e);
    throw e;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.then(function() {
  ui.log('info', 'Building the bundle tree for `' + moduleExpression + '`...');

  return systemBuilder.trace(moduleExpression);
})
.then(function(buildTree) {
  logTree(buildTree);
  return systemBuilder.<span class="apidocCodeKeywordSpan">bundle</span>(buildTree, fileName, opts);
})
.then(function(output) {
  if (opts.injectConfig)
    ui.log('ok', '`' + output.bundleName + '` added to config bundles.');

  logBuild(path.relative(process.cwd(), fileName), opts);
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.bundle.Builder" id="apidoc.element.jspm.bundle.Builder">
        function <span class="apidocSignatureSpan">jspm.bundle.</span>Builder
        <span class="apidocSignatureSpan">(_config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Builder(_config) {
  config.loadSync();
  SystemJSBuilder.call(this, toFileURL(config.pjson.baseURL));

  var cfg = config.loader.getConfig();

  if (cfg.depCache)
    delete cfg.depCache;
  if (cfg.bundles)
    delete cfg.bundles;
  if (cfg.baseURL)
    delete cfg.baseURL;

  this.config(cfg, true);

  if (typeof _config == 'object')
    this.config(_config, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.bundle.bundleSFX" id="apidoc.element.jspm.bundle.bundleSFX">
        function <span class="apidocSignatureSpan">jspm.bundle.</span>bundleSFX
        <span class="apidocSignatureSpan">(expression, fileName, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bundleSFX = function (expression, fileName, opts) {
  var systemBuilder = new Builder();

  opts = opts || {};

  fileName = fileName || path.resolve(config.pjson.baseURL, 'build.js');

  return Promise.resolve()
  .then(function() {
    if (!opts.sourceMaps)
      return removeExistingSourceMap(fileName);
  })
  .then(function() {
    ui.log('info', 'Building the single-file sfx bundle for `' + expression + '`...');

    opts.format = opts.format || 'global';

    return systemBuilder.buildStatic(expression, fileName, opts);
  })
  .then(function() {
    logBuild(path.relative(process.cwd(), fileName), opts);
  })
  .catch(function(e) {
    // catch sfx globals error to give a better error message
    if (e.toString().indexOf('globalDeps option') != -1) {
      var module = e.toString().match(/dependency "([^"]+)"/);
      ui.log('err', 'SFX exclusion "' + module[1] + '" needs a reference.\nEither output an SFX module format like %--format amd
% or map the module to an environment global via %--globals "{\'test.js\': \'test\'}"%.');
      throw 'SFX Bundle input error';
    }

    ui.log('err', e.stack || e);
    throw e;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.bundle.depCache" id="apidoc.element.jspm.bundle.depCache">
        function <span class="apidocSignatureSpan">jspm.bundle.</span>depCache
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">depCache = function (expression) {
  var systemBuilder = new Builder();

  expression = expression || config.loader.main;

  ui.log('info', 'Injecting the traced dependency tree for `' + expression + '`...');

  return systemBuilder.trace(expression)
  .then(function(tree) {
    logTree(tree);
    var depCache = config.loader.depCache || {};
    extend(depCache, systemBuilder.getDepCache(tree));
    config.loader.depCache = depCache;
  })
  .then(config.save)
  .then(function() {
    ui.log('ok', 'Dependency tree injected');
  })
  .catch(function(e) {
    ui.log('err', e.stack || e);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 'depcache':
  options = readOptions(args, ['yes']);
  if (options.yes)
    ui.useDefaults();
  if (!args[1])
    ui.log('warn', 'depCache requires a module name to trace.');
  else
    bundle.<span class="apidocCodeKeywordSpan">depCache</span>(args[1]);
  break;

case 'b':
case 'bundle-sfx':
  var sfxBundle = true;

case 'bundle':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.bundle.unbundle" id="apidoc.element.jspm.bundle.unbundle">
        function <span class="apidocSignatureSpan">jspm.bundle.</span>unbundle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbundle = function () {
  return config.load()
  .then(function() {
    config.loader.bundles = {};
    config.loader.depCache = {};
    return config.save();
  })
  .then(function() {
    ui.log('ok', 'Bundle configuration removed.');
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    .catch(function() {
      process.exit(1);
    });
  }
  break;

case 'unbundle':
  bundle.<span class="apidocCodeKeywordSpan">unbundle</span>()
  .catch(function(e) {
    ui.log('err', e.stack || e);
    process.exit(1);
  });
  break;

case 'build':
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.common" id="apidoc.module.jspm.common">module jspm.common</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.common.alphabetize" id="apidoc.element.jspm.common.alphabetize">
        function <span class="apidocSignatureSpan">jspm.common.</span>alphabetize
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alphabetize = function (obj) {
  var newObj = {};
  Object.keys(obj).sort().forEach(function(p) {
    newObj[p] = obj[p];
  });
  return newObj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.common.cascadeDelete" id="apidoc.element.jspm.common.cascadeDelete">
        function <span class="apidocSignatureSpan">jspm.common.</span>cascadeDelete
        <span class="apidocSignatureSpan">(dir, stopDir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cascadeDelete(dir, stopDir) {
  if (dir &amp;&amp; dir !== stopDir) {
    return asp(fs.rmdir)(dir)
    .catch(function(err) {
      // just continue if directory does not exist
      if (err.code !== 'ENOENT')
        throw err;
    })
    .then(function() {
      return cascadeDelete(path.dirname(dir), stopDir);
    })
    .catch(function(err) {
      // gracefully stop at first non-empty directory
      if (err.code !== 'ENOTEMPTY')
        throw err;
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.common.dextend" id="apidoc.element.jspm.common.dextend">
        function <span class="apidocSignatureSpan">jspm.common.</span>dextend
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dextend(a, b) {
  for (var p in b) {
    if (!b.hasOwnProperty(p))
      continue;
    var val = b[p];
    if (typeof val === 'object')
      dextend(a[p] = typeof a[p] === 'object' ? a[p] : {}, val);
    else
      a[p] = val;
  }
  return a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.common.dprepend" id="apidoc.element.jspm.common.dprepend">
        function <span class="apidocSignatureSpan">jspm.common.</span>dprepend
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dprepend(a, b) {
  for (var p in b) {
    if (!b.hasOwnProperty(p))
      continue;

    var val = b[p];
    if (typeof val === 'object')
      dprepend(a[p] = typeof a[p] === 'object' ? a[p] : {}, val);
    else if (!(p in a))
      a[p] = val;
  }
  return a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.common.extend" id="apidoc.element.jspm.common.extend">
        function <span class="apidocSignatureSpan">jspm.common.</span>extend
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (a, b) {
  for (var p in b) {
    if (b.hasOwnProperty(p)) {
      a[p] = b[p];
    }
  }
  return a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.common.fromFileURL" id="apidoc.element.jspm.common.fromFileURL">
        function <span class="apidocSignatureSpan">jspm.common.</span>fromFileURL
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromFileURL(path) {
  return path.substr(process.platform.match(/^win/) ? 8 : 7).replace(path.sep, '/');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.common.getRedirectContents" id="apidoc.element.jspm.common.getRedirectContents">
        function <span class="apidocSignatureSpan">jspm.common.</span>getRedirectContents
        <span class="apidocSignatureSpan">(format, main)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRedirectContents = function (format, main) {
  if (format === 'es6' || format === 'esm')
    return 'export * from "' + main + '";\nexport {default} from "' + main + '";';

  else if (format === 'cjs' || format === 'global')
    return 'module.exports = require("' + main + '");';

  else if (format === 'amd')
    return 'define(["' + main + '"], function(main) {\n  return main;\n});';

  else if (format === 'register')
    return 'System.register(["' + main + '"], ' +
      'function($__export) {\n  return {  setters: [function(m) { for (var p in m) $__export(p, m[p]); }],  execute: function() {}  };\n});';

  else
    throw 'Unknown module format ' + format + '.';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.common.hasProperties" id="apidoc.element.jspm.common.hasProperties">
        function <span class="apidocSignatureSpan">jspm.common.</span>hasProperties
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasProperties = function (obj) {
  for (var p in obj) {
    if (obj.hasOwnProperty(p))
      return true;
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.common.readJSON" id="apidoc.element.jspm.common.readJSON">
        function <span class="apidocSignatureSpan">jspm.common.</span>readJSON
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readJSON = function (file) {
  return asp(fs.readFile)(file)
  .then(function(pjson) {
    pjson = pjson.toString();
    // remove any byte order mark
    if (pjson.startsWith('\uFEFF'))
      pjson = pjson.substr(1);
    try {
      return JSON.parse(pjson);
    }
    catch(e) {
      throw 'Error parsing package.json file ' + file;
    }
  }, function(err) {
    if (err.code === 'ENOENT')
      return {};
    throw err;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.common.readJSONSync" id="apidoc.element.jspm.common.readJSONSync">
        function <span class="apidocSignatureSpan">jspm.common.</span>readJSONSync
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readJSONSync = function (file) {
  var pjson;
  try {
    pjson = fs.readFileSync(file).toString();
  }
  catch(e) {
    if (e.code === 'ENOENT')
      pjson = '{}';
    else
      throw e;
  }
  if (pjson.startsWith('\uFEFF'))
    pjson = pjson.substr(1);
  try {
    return JSON.parse(pjson);
  }
  catch(e) {
    throw 'Error parsing package.json file ' + file;
  }
  return pjson;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.common.stringify" id="apidoc.element.jspm.common.stringify">
        function <span class="apidocSignatureSpan">jspm.common.</span>stringify
        <span class="apidocSignatureSpan">(subject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringify = function (subject) {
  return JSON.stringify(subject, null, tab).replace(/\n/g, newLine);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    'function($__export) {\n  return {  setters: [function(m) { for (var p in m) $__export(p, m[p]); }],  execute: function
() {}  };\n});';

else
  throw 'Unknown module format ' + format + '.';
};

exports.stringify = function (subject) {
return JSON.<span class="apidocCodeKeywordSpan">stringify</span>(subject, null, tab).replace(/\n/g, newLine);
};

/* Recursively remove directory, all those above it, if they are empty.
 * Takes optional `stopDir` to terminate at. */
function cascadeDelete(dir, stopDir) {
if (dir &amp;&amp; dir !== stopDir) {
  return asp(fs.rmdir)(dir)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.common.toFileURL" id="apidoc.element.jspm.common.toFileURL">
        function <span class="apidocSignatureSpan">jspm.common.</span>toFileURL
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toFileURL(path) {
  return 'file://' + (process.platform.match(/^win/) ? '/' : '') + path.replace(/\\/g, '/');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.config" id="apidoc.module.jspm.config">module jspm.config</a></h1>




    <h2>
        <a href="#apidoc.element.jspm.config.derivePackageConfig" id="apidoc.element.jspm.config.derivePackageConfig">
        function <span class="apidocSignatureSpan">jspm.config.</span>derivePackageConfig
        <span class="apidocSignatureSpan">(pjson, override)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">derivePackageConfig = function (pjson, override) {
  var dpjson = extend({}, pjson);

  // first derive the override
  if (override || pjson.jspm)
    dpjson.jspm = extend({}, pjson.jspm || {});

  if (override)
    extend(dpjson.jspm, override);

  // then apply the override
  if (override || pjson.jspm)
    extend(dpjson, dpjson.jspm);

  return dpjson;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!registry)
  throw 'Package registry not specified.';
if (!version)
  throw 'Package version not specified.';

pkg = new PackageName(registry + ':' + packageName + '@' + version);

return package.<span class="apidocCodeKeywordSpan">derivePackageConfig</span>(pkg, _pjson);
  })
  .then(function(_pjson) {
pjson = _pjson;

linkDir = path.resolve(config.HOME, '.jspm', 'linked', pkg.registry, pkg.exactPackage);
try {
  if (fs.existsSync(linkDir)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.config.load" id="apidoc.element.jspm.config.load">
        function <span class="apidocSignatureSpan">jspm.config.</span>load
        <span class="apidocSignatureSpan">(prompts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (prompts) {
  if (loadPromise)
    return loadPromise;

  return (loadPromise = Promise.resolve()
  .then(function() {

    if (process.env.globalJspm === 'true')
      ui.log('warn', 'Running jspm globally, it is advisable to locally install jspm via %npm install jspm --save-dev%.');

    if (!process.env.jspmConfigPath)
      return ui.confirm('Package.json file does not exist, create it?', true)
      .then(function(create) {
        if (!create)
          throw 'Operation aborted.';
      });
  })
  .then(function() {
    config.pjsonPath = process.env.jspmConfigPath || path.resolve(process.cwd(), 'package.json');

    config.pjson = new PackageConfig(config.pjsonPath);
    return config.pjson.read(prompts);
  })
  .then(function(_prompts) {
    // package.json can indicate if we need to run config prompts for a new package
    prompts = prompts || _prompts;

    if (fs.existsSync(config.pjson.configFile))
      return;

    return ui.confirm('Configuration file %' + path.relative(process.cwd(), config.pjson.configFile) + '% doesn\'t exist, create
 it?', true)
    .then(function(create) {
      if (!create)
        throw 'Operation aborted.';

      // ensure config folder exists
      return asp(mkdirp)(path.dirname(config.pjson.configFile));
    });
  })
  .then(function() {
    config.loader = new LoaderConfig(config.pjson.configFile);
    return config.loader.read(prompts);
  })
  .then(function() {
    return readJSON(path.resolve(config.pjson.packages, '.dependencies.json'));
  })
  .then(function(depsJSON) {
    config.deps = setSerializedDeps(depsJSON);
    config.loaded = true;
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
break;

    case 'inspect':
options = readOptions(args, ['forks']);
args = options.args;

config.<span class="apidocCodeKeywordSpan">load</span>()
.then(function() {
  if (!args[1])
    return install.showVersions(options.forks);
  if (!args[1].includes(':'))
    return ui.log('warn', 'Enter a full package name of the format `registry:repo`.');
  return install.showInstallGraph(args[1]);
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.config.loadSync" id="apidoc.element.jspm.config.loadSync">
        function <span class="apidocSignatureSpan">jspm.config.</span>loadSync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadSync = function () {
  if (config.loaded)
    return;
  if (loadPromise)
    throw 'Configuration file is already loading.';
  config.pjsonPath = process.env.jspmConfigPath || path.resolve(process.cwd(), 'package.json');
  config.pjson = new PackageConfig(config.pjsonPath);
  config.pjson.read(false, true);

  if (!fs.existsSync(config.pjson.configFile))
    throw 'No project configuration file not found. Looking for: ' + config.pjson.configFile;

  config.loader = new LoaderConfig(config.pjson.configFile);
  config.loader.read(false, true);

  var depsJSON;
  try {
    depsJSON = JSON.parse(fs.readFileSync(path.resolve(config.pjson.packages, '.dependencies.json')));
  }
  catch(e) {
    if (e.code == 'ENOENT')
      depsJSON = {};
    else
      throw e;
  }

  config.deps = setSerializedDeps(depsJSON);

  config.loaded = true;
  loadPromise = Promise.resolve();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var extend = require('./common').extend;
var alphabetize = require('./common').alphabetize;
var toFileURL = require('./common').toFileURL;

// jspm version of builder ignores config, baseURL arguments
// just allows cfg object
function Builder(_config) {
config.<span class="apidocCodeKeywordSpan">loadSync</span>();
SystemJSBuilder.call(this, toFileURL(config.pjson.baseURL));

var cfg = config.loader.getConfig();

if (cfg.depCache)
  delete cfg.depCache;
if (cfg.bundles)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.config.save" id="apidoc.element.jspm.config.save">
        function <span class="apidocSignatureSpan">jspm.config.</span>save
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">save = function () {
  if (savePromise)
    return savePromise.then(exports.save);

  return Promise.resolve()
  .then(function() {
    return config.loader.write();
  })
  .then(function() {
    return config.pjson.write();
  })
  .then(function() {
    return asp(mkdirp)(config.pjson.packages);
  })
  .then(function() {
    return asp(fs.writeFile)(path.resolve(config.pjson.packages, '.dependencies.json'), JSON.stringify(getSerializedDeps(config.
deps), null, 2));
  })
  .then(function() {
    savePromise = undefined;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    output.bundleName = output.bundleName || self.getCanonicalName(toFileURL(path.resolve(opts.outFile)));
    var bundleName = output.bundleName;

    if (!config.loader.bundles)
      config.loader.bundles = {};

    config.loader.bundles[bundleName] = output.modules;
    return config.<span class="apidocCodeKeywordSpan">save</span>()
    .then(function() {
      return output;
    });
  }

  return output;
});
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.core" id="apidoc.module.jspm.core">module jspm.core</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.core.build" id="apidoc.element.jspm.core.build">
        function <span class="apidocSignatureSpan">jspm.core.</span>build
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">build = function () {
  var saveConfig = false;

  return config.load()
  .then(function() {
    if (config.pjson.buildConfig.transpileES6 === undefined) {
      saveConfig = true;
      return ui.confirm('Transpile ES6?', true);
    }
  })
  .then(function(doTranspile) {
    if (doTranspile)
      config.pjson.buildConfig.transpileES6 = true;

    if (!config.pjson.buildConfig || config.pjson.buildConfig.minify === undefined) {
      saveConfig = true;
      return ui.confirm('Minify?', true);
    }
  })
  .then(function(doMinify) {
    if (doMinify)
      config.pjson.buildConfig.minify = true;

    if (saveConfig)
      return config.save();
  })
  .then(function() {
    return asp(rimraf)(config.pjson.dist);
  })
  .then(function() {
    return asp(ncp)(config.pjson.lib, config.pjson.dist);
  })
  .then(function() {
    return build.compileDir(config.pjson.dist, {
      format: config.pjson.format,
      map: config.pjson.map,
      transpile: config.pjson.buildConfig.transpileES6,
      minify: config.pjson.buildConfig.minify,
      removeJSExtensions: config.pjson.useJSExtensions
    });
  })
  .then(function(compileErrors) {
    if (compileErrors)
      ui.log('warn', 'Compile Errors:\n' + compileErrors);
    else
      ui.log('ok', 'Build Completed');
  }, function(err) {
    ui.log('err', err.stack || err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
  break;

case 'build':
  options = readOptions(args, ['yes']);
  if (options.yes)
    ui.useDefaults();
  core.<span class="apidocCodeKeywordSpan">build</span>();
  break;

case 'compile':
  options = readOptions(args, ['transpile', 'minify', 'removeJSExtensions', 'yes'], ['
;map', 'format']);
  if (options.yes)
    ui.useDefaults();
  if (options.map) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.core.cacheClear" id="apidoc.element.jspm.core.cacheClear">
        function <span class="apidocSignatureSpan">jspm.core.</span>cacheClear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cacheClear = function () {
  var jspmDir = path.resolve(config.HOME, '.jspm'),
      packagesCacheDir = path.join(jspmDir, 'packages'),
      loaderCacheDir = path.join(jspmDir, 'loader-files'),
      files, filesLength, fileName, i;

  // Clear loader files
  if (fs.existsSync(loaderCacheDir))
    rimraf.sync(loaderCacheDir);
  ui.log('ok', 'Loader file cache cleared.');

  // Clear packages cache folder
  if (fs.existsSync(packagesCacheDir))
    rimraf.sync(packagesCacheDir);
  ui.log('ok', 'Package cache cleared.');

  // Clear registry cache folders
  files = fs.readdirSync(jspmDir);
  filesLength = files.length;
  for (i = 0; i &lt; filesLength; i++) {
    fileName = files[i];
    if (fileName.endsWith('-cache')) {
      rimraf.sync(path.join(jspmDir, fileName));
      ui.log('ok', '%' + fileName.substr(0, fileName.length - '-cache'.length) + '% cache cleared.');
    }
  }

  ui.log('warn', 'All caches cleared.');
  ui.log('info', 'Please post an issue if you suspect the cache isn\'t invalidating properly.');
  ui.log('info', '%jspm install -f% is equivalent to running a cache clear for that specific package tree.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var property = args[1];
  var value = readValue(args.splice(2).join(' '));
  globalConfig.set(property, value);
  break;

case 'cc':
case 'cache-clear':
  core.<span class="apidocCodeKeywordSpan">cacheClear</span>();
  break;

case '--help':
case '-h':
  showInstructions();
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.core.checkDlLoader" id="apidoc.element.jspm.core.checkDlLoader">
        function <span class="apidocSignatureSpan">jspm.core.</span>checkDlLoader
        <span class="apidocSignatureSpan">(transpilerName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkDlLoader = function (transpilerName) {
  return config.load()
  .then(function() {
    transpilerName = transpilerName || config.loader.transpiler || globalConfig.config.defaultTranspiler;
    var tPkgs = [];
    if (transpilerName === 'traceur')
      tPkgs = ['traceur', 'traceur-runtime'];
    else if (transpilerName === 'babel')
      tPkgs = ['babel', 'babel-runtime', 'core-js'];
    else if (transpilerName === 'typescript')
      tPkgs = ['typescript'];

    tPkgs.forEach(function(p) {
      if (config.loader.baseMap[p])
        if (config.loader.baseMap[p].version !== tPackages[p].split('@').pop() &amp;&amp; !nodeSemver.satisfies(config.loader.baseMap[p].
version, tPackages[p].split('@').pop()))
          ui.log('warn', '`' + p + '@' + config.loader.baseMap[p].version + '` is unsupported for this version of jspm. Use %jspm
 dl-loader --latest% to update.');
    });
  })
  .then(function() {
    return asp(fs.readFile)(path.resolve(config.pjson.packages, '.loaderversions'));
  })
  .catch(function(err) {
    if (err.code === 'ENOENT')
      return '';
    throw err;
  })
  .then(function(cacheVersions) {
    if (cacheVersions.toString() !== systemVersion)
      return exports.dlLoader(transpilerName);

    // even if version file is fresh, still check files exist
    return asp(fs.readdir)(config.pjson.packages)
    .catch(function(err) {
      if (err.code === 'ENOENT')
        return [];
      throw err;
    })
    .then(function(files) {
      if (files.indexOf('system.js') === -1)
        return exports.dlLoader(transpilerName);
      return exports.dlTranspiler(transpilerName);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// jspm install with no arguments is locked
if (!depMap &amp;&amp; !doUpdate)
  options.lock = true;

// no install package -&gt; install from package.json dependencies
(depMap ? install.install(depMap, options) : install.install(true, options))
.then(function() {
  return core.<span class="apidocCodeKeywordSpan">checkDlLoader</span>();
})
.then(function() {
  return core.setMode(inject ? 'remote' : 'local');
})
.then(function() {
  ui.log('');
  ui.log('ok', 'Install complete.');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.core.dlLoader" id="apidoc.element.jspm.core.dlLoader">
        function <span class="apidocSignatureSpan">jspm.core.</span>dlLoader
        <span class="apidocSignatureSpan">(transpilerName, unminified, edge, latest)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dlLoader = function (transpilerName, unminified, edge, latest) {
  ui.log('info', 'Looking up loader files...');
  var min = unminified ? '.src' : '';

  var using = {};

  return config.load()
  .then(function() {
    return asp(mkdirp)(config.pjson.packages);
  })
  .then(function() {
    // delete old versions
    return asp(fs.readdir)(config.pjson.packages);
  })
  .then(function(files) {
    return Promise.all(files.filter(function(file) {
      return file.match(/^(system-csp|system-csp-production|system|es6-module-loader|traceur|babel|system-polyfills|typescript)/);
    }).map(function(file) {
      return asp(fs.unlink)(path.resolve(config.pjson.packages, file));
    }));
  })
  .then(function() {
    return dl('systemjs', 'github:systemjs/systemjs', !edge ? (!latest ? systemVersion : '^' + systemVersion) : 'master')
    .then(function(version) {
      using.system = version;
      return Promise.all([
        cp('systemjs/dist/system' + min + '.js', 'system.js'),
        unminified || cp('systemjs/dist/system.src.js', 'system.src.js'),
        unminified || cp('systemjs/dist/system.js.map', 'system.js.map'),
        cp('systemjs/dist/system-csp-production' + min + '.js', 'system-csp-production.js'),
        unminified || cp('systemjs/dist/system-csp-production.src.js', 'system-csp-production.src.js'),
        unminified || cp('systemjs/dist/system-csp-production.js.map', 'system-csp-production.js.map'),
        cp('systemjs/dist/system-polyfills' + min + '.js', 'system-polyfills.js'),
        unminified || cp('systemjs/dist/system-polyfills.src.js', 'system-polyfills.src.js'),
        unminified || cp('systemjs/dist/system-polyfills.js.map', 'system-polyfills.js.map')
      ]);
    });
  })
  .then(function() {
    ui.log('info', '\nUsing loader versions:');
    ui.log('info', '  `systemjs@' + using.system + '`');

    return asp(fs.writeFile)(path.resolve(config.pjson.packages, '.loaderversions'), systemVersion);
  })
  .then(function() {
    return exports.dlTranspiler(transpilerName, latest);
  })
  .then(function() {
    ui.log('ok', 'Loader files downloaded successfully');
  }, function(err) {
    ui.log('err', err);
    ui.log('err', 'Error downloading loader files.');
    throw err;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  core.init(options.args[1], options.prompts);
  break;

case 'dl-loader':
  options = readOptions(args, ['source', 'latest', 'edge', 'yes', 'traceur', &amp;#
x27;babel', 'typescript']);
  if (options.yes)
    ui.useDefaults();
  core.<span class="apidocCodeKeywordSpan">dlLoader</span>(options.args[1] || options.traceur &amp;&amp; 'traceur' ||
options.babel &amp;&amp; 'babel' || options.typescript &amp;&amp; 'typescript', options.source, options.
edge, options.latest);
  break;

case 'setmode':
  options = readOptions(args, ['yes']);
  if (options.yes)
    ui.useDefaults();
  core.setMode(args.splice(1))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.core.dlTranspiler" id="apidoc.element.jspm.core.dlTranspiler">
        function <span class="apidocSignatureSpan">jspm.core.</span>dlTranspiler
        <span class="apidocSignatureSpan">(transpilerName, update)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dlTranspiler = function (transpilerName, update) {
  return config.load()
  .then(function() {
    var installObj = {};

    transpilerName = transpilerName || config.loader.transpiler || globalConfig.config.defaultTranspiler;

    // skip download if not using a transpiler
    if (transpilerName === 'none')
      return;

    // read existing transpiler from package.json install
    var target = !update &amp;&amp; (config.pjson.devDependencies[transpilerName] || config.pjson.dependencies[transpilerName]);
    if (target)
      installObj[transpilerName] = target.exactName;
    else
      installObj[transpilerName] = transpilerName === 'traceur' ? tPackages.traceur : transpilerName === 'typescript' || transpilerName
 == 'ts' ? tPackages.typescript : tPackages.babel;

    // typescript does not have runtime library
    if (transpilerName !== 'typescript') {
      target = !update &amp;&amp; (config.pjson.devDependencies[transpilerName + '-runtime'] || config.pjson.dependencies[transpilerName
 + '-runtime']);
      if (target)
        installObj[transpilerName + '-runtime'] = target.exactName;
      else
        installObj[transpilerName + '-runtime'] = transpilerName === 'traceur' ? tPackages['traceur-runtime'] : tPackages['babel
-runtime'];
    }

    if (transpilerName === 'babel') {
      target = !update &amp;&amp; (config.pjson.devDependencies['core-js'] || config.pjson.dependencies['core-js']);
      if (target)
        installObj['core-js'] = target.exactName;
      else
        installObj['core-js'] = tPackages['core-js'];
    }

    // just do a quick install which checks basic existence
    return install.install(installObj, { quick: !update, dev: true, summary: false });
  })
  .then(function() {
    if (config.loader.transpiler !== transpilerName) {
      config.loader.transpiler = transpilerName;

      if (transpilerName !== 'none')
        ui.log('ok', 'ES6 transpiler set to %' + transpilerName + '%.');
    }
    if (transpilerName === 'babel')
      if (!config.loader.babelOptions.optional)
        config.loader.babelOptions.optional = ['runtime', 'optimisation.modules.system'];
    return config.save();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (err.code === 'ENOENT')
        return [];
      throw err;
    })
    .then(function(files) {
      if (files.indexOf('system.js') === -1)
        return exports.dlLoader(transpilerName);
      return exports.<span class="apidocCodeKeywordSpan">dlTranspiler</span>(transpilerName);
    });
  });
};

// mini registry API usage implementation
var loaderFilesCacheDir = path.join(config.HOME, '.jspm', 'loader-files');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.core.init" id="apidoc.element.jspm.core.init">
        function <span class="apidocSignatureSpan">jspm.core.</span>init
        <span class="apidocSignatureSpan">(basePath, ask)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function init(basePath, ask) {
  if (basePath)
    process.env.jspmConfigPath = path.resolve(basePath, 'package.json');
  var relBase = path.relative(process.cwd(), path.dirname(process.env.jspmConfigPath));
  if (relBase !== '')
    ui.log('info', 'Initializing package at `' + relBase + '/`\nUse %jspm init .% to intialize into the current folder.');
  return config.load(ask)
  .then(function() {
    return config.save();
  })
  .then(function() {
    ui.log('ok', 'Verified package.json at %' + path.relative(process.cwd(), config.pjsonPath) + '%\nVerified config file at %' +
path.relative(process.cwd(), config.pjson.configFile) + '%');
  })
  .then(function() {
    return core.checkDlLoader();
  })
  .catch(function(err) {
    ui.log('err', err &amp;&amp; err.stack || err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
  break;

case 'init':
  options = readOptions(args, ['yes', 'prompts']);
  if (options.yes)
    ui.useDefaults();
  core.<span class="apidocCodeKeywordSpan">init</span>(options.args[1], options.prompts);
  break;

case 'dl-loader':
  options = readOptions(args, ['source', 'latest', 'edge', 'yes', 'traceur', &amp;#
x27;babel', 'typescript']);
  if (options.yes)
    ui.useDefaults();
  core.dlLoader(options.args[1] || options.traceur &amp;&amp; 'traceur' || options.babel &amp;&amp; 'babel'
; || options.typescript &amp;&amp; 'typescript', options.source, options.edge, options.latest);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.core.run" id="apidoc.element.jspm.core.run">
        function <span class="apidocSignatureSpan">jspm.core.</span>run
        <span class="apidocSignatureSpan">(moduleName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (moduleName) {
  return config.load()
  .then(function() {
    var cfg = config.loader.getConfig();
    delete cfg.bundles;
    cfg.baseURL = toFileURL(config.pjson.baseURL);
    System.config(cfg);

    return System.import(moduleName);
  })
  .catch(function(e) {
    ui.log('err', e.stack || e);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var cwdArgIndex = args.indexOf('--cwd');
  if (cwdArgIndex &gt; -1) {
args.splice(cwdArgIndex, 2);
  }

  switch(args[0]) {
case 'run':
  core.<span class="apidocCodeKeywordSpan">run</span>(args[1]);
  break;

case 'inject':
  var inject = true;

case 'update':
  var doUpdate = !inject;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.core.setMode" id="apidoc.element.jspm.core.setMode">
        function <span class="apidocSignatureSpan">jspm.core.</span>setMode
        <span class="apidocSignatureSpan">(modes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMode = function (modes) {
  if (!(modes instanceof Array))
    modes = [modes];

  var msg = '';

  return config.load()
  .then(function() {
    if (modes.indexOf('local') === -1)
      return true;

    // set local
    Object.keys(config.loader.registries).forEach(function(e) {
      config.loader.registries[e].setLocal();
    });

    msg += 'Loader set to local library sources\n';
  })
  .then(function(unmatched) {
    if (modes.indexOf('remote') === -1)
      return unmatched;

    // set remote
    Object.keys(config.loader.registries).forEach(function(e) {
      config.loader.registries[e].setRemote();
    });

    msg += 'Loader set to CDN library sources\n';
  })
  .then(function(unmatched) {
    if (unmatched)
      return ui.log('warn', 'Invalid mode');

    return config.save()
    .then(function() {
      return msg;
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// no install package -&gt; install from package.json dependencies
(depMap ? install.install(depMap, options) : install.install(true, options))
.then(function() {
  return core.checkDlLoader();
})
.then(function() {
  return core.<span class="apidocCodeKeywordSpan">setMode</span>(inject ? 'remote' : 'local');
})
.then(function() {
  ui.log('');
  ui.log('ok', 'Install complete.');
  process.exit();
}, function(err) {
  // something happened (cancel / err)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.global_config" id="apidoc.module.jspm.global_config">module jspm.global_config</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.global_config.save" id="apidoc.element.jspm.global_config.save">
        function <span class="apidocSignatureSpan">jspm.global_config.</span>save
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function save() {
  try {
    fs.mkdirSync(HOME + path.sep + '.jspm');
  }
  catch (e) {
    if (e.code !== 'EEXIST')
      throw 'Unable to create jspm system folder\n' + e.stack;
  }
  try {
    lock();
    var existing = readJSONSync(globalConfigFile);
    // only write to a new file if the local changes are different
    if (JSON.stringify(existing) != JSON.stringify(exports.config)) {
      fs.writeFileSync(globalConfigFile, stringify(exports.config));
    }
  }
  catch (e) {
    throw 'Unable to write global configuration file\n' + e.stack;
  }
  finally {
    unlock();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    output.bundleName = output.bundleName || self.getCanonicalName(toFileURL(path.resolve(opts.outFile)));
    var bundleName = output.bundleName;

    if (!config.loader.bundles)
      config.loader.bundles = {};

    config.loader.bundles[bundleName] = output.modules;
    return config.<span class="apidocCodeKeywordSpan">save</span>()
    .then(function() {
      return output;
    });
  }

  return output;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.global_config.set" id="apidoc.element.jspm.global_config.set">
        function <span class="apidocSignatureSpan">jspm.global_config.</span>set
        <span class="apidocSignatureSpan">(name, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (name, val) {
  var nameParts = name.split('.');

  var config = exports.config;
  var part;
  while (nameParts.length &gt; 1) {
    part = nameParts.shift();
    config[part] = typeof config[part] === 'object' ? config[part] : {};
    config = config[part];
  }
  if (val !== undefined) {
    config[nameParts[0]] = val;
  }
  else {
    // If no value is specified, then remove property from config
    delete config[nameParts[0]];
  }

  save();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  break;

case 'c':
case 'config':
  var property = args[1];
  var value = readValue(args.splice(2).join(' '));
  globalConfig.<span class="apidocCodeKeywordSpan">set</span>(property, value);
  break;

case 'cc':
case 'cache-clear':
  core.cacheClear();
  break;
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.install" id="apidoc.module.jspm.install">module jspm.install</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.install.install" id="apidoc.element.jspm.install.install">
        function <span class="apidocSignatureSpan">jspm.</span>install
        <span class="apidocSignatureSpan">(targets, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">install = function (targets, options) {
  if (typeof targets === 'string') {
    var name = targets;
    targets = {};
    targets[name] = typeof options === 'string' ? options : '';
    options = typeof options === 'object' ? options : arguments[2];
  }
  options = options || {};

  return config.load()
  .then(function() {
    installed = installed || config.loader;

    if (options.force)
      config.force = true;

    if (options.link || options.quick)
      options.lock = true;

    var d, existingTargets = {};

    if (!options.production) {
      for (d in config.pjson.devDependencies)
        existingTargets[d] = config.pjson.devDependencies[d];
    }

    for (d in config.pjson.dependencies)
      existingTargets[d] = config.pjson.dependencies[d];

    if (targets === true)
      targets = existingTargets;
    // check and set targets for update
    else if (targets &amp;&amp; options.update)
      for (d in targets) {
        if (!existingTargets[d])
          throw '%' + d + '% is not an existing dependency to update.';
        targets[d] = existingTargets[d];
      }

    targets = pkg.processDeps(targets, globalConfig.config.defaultRegistry);

    return Promise.all(Object.keys(targets).map(function(name) {
      return install(name, targets[name], options);
    }))
    .then(function() {
      return saveInstall();
    })
    .then(function() {
      // after every install, show fork and resolution summary
      if (options.summary !== false)
        showVersions(true);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ui.useDefaults();

// jspm install with no arguments is locked
if (!depMap &amp;&amp; !doUpdate)
  options.lock = true;

// no install package -&gt; install from package.json dependencies
(depMap ? install.<span class="apidocCodeKeywordSpan">install</span>(depMap, options) : install.install(true, options))
.then(function() {
  return core.checkDlLoader();
})
.then(function() {
  return core.setMode(inject ? 'remote' : 'local');
})
.then(function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.install.clean" id="apidoc.element.jspm.install.clean">
        function <span class="apidocSignatureSpan">jspm.install.</span>clean
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clean() {
  var packageList = [];

  return config.load()
  .then(function() {

    // 1. getDependentPackages for each of baseMap
    Object.keys(config.loader.baseMap).forEach(function(dep) {
      getDependentPackages(config.loader.baseMap[dep].exactName, packageList);
    });

    // 2. now that we have the package list, remove everything not in it
    Object.keys(config.loader.depMap).forEach(function(dep) {
      if (packageList.indexOf(dep) === -1) {
        ui.log('info', 'Clearing configuration for `' + dep + '`');
        delete config.loader.depMap[dep];
      }
    });

    // 3. remove package.json overrides which will never match any packages
    var usedOverrides = [];
    packageList.forEach(function(pkgName) {
      var pkgVersion = pkgName.split('@').pop();
      pkgName = pkgName.substr(0, pkgName.length - pkgVersion.length - 1);

      var overrideVersion = Object.keys(config.pjson.overrides)
      .filter(function(overrideName) {
        return overrideName.startsWith(pkgName + '@');
      })
      .map(function(overrideName) {
        return overrideName.split('@').pop();
      })
      .filter(function(overrideVersion) {
        return semver.match('^' + overrideVersion, pkgVersion);
      })
      .sort(semver.compare).pop();
      if (overrideVersion)
        usedOverrides.push(pkgName + '@' + overrideVersion);
    });
    Object.keys(config.pjson.overrides).forEach(function(overrideName) {
      if (usedOverrides.indexOf(overrideName) == -1) {
        ui.log('info', 'Removing unused package.json override `' + overrideName + '`');
        delete config.pjson.overrides[overrideName];
      }
    });
  })

  .then(function() {
    return asp(fs.lstat)(config.pjson.packages)
    .catch(function(e) {
      if (e.code == 'ENOENT')
        return;
      throw e;
    }).then(function(stats) {
      // Skip if jspm_packages is symlinked or not existing
      if (!stats || stats.isSymbolicLink())
        return;

      // 4. Remove packages in .dependencies.json that aren't used at all
      Object.keys(config.deps).forEach(function(dep) {
        if (packageList.indexOf(dep) == -1)
          delete config.deps[dep];
      });

      // 5. Remove anything from jspm_packages not in this list
      return readDirWithDepth(config.pjson.packages, function(dirname) {
        if (dirname.split(path.sep).pop().indexOf('@') &lt;= 0)
          return true;
      })
      .then(function(packageDirs) {
        return Promise.all(
        packageDirs
        .filter(function(dir) {
          var exactName = path.relative(config.pjson.packages, dir).replace(path.sep, ':').replace(/\\/g, '/'); // (win)
          var remove = packageList.indexOf(exactName) === -1;
          if (remove)
            ui.log('info', 'Removing package files for `' + exactName + '`');
          return remove;
        })
        .map(function(dir) {
          return asp(rimraf)(dir)
          .then(function() {
            var filename = dir + '.js';
            return new Promise(function(resolve) {
              fs.exists(filename, resolve);
            }).then(function(exists) {
              if (exists) return asp(fs.unlink)(filename);
            });
          })
          .then(function() {
            return cascadeDelete(dir);
          });
        }));
      });
    });
  })

  .then(function() {
    return config.save();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    case 'clean':
options = readOptions(args, ['yes']);
args = options.args;

if (options.yes)
  ui.useDefaults();

install.<span class="apidocCodeKeywordSpan">clean</span>()
.then(function() {
  ui.log('');
  ui.log('ok', 'Project cleaned successfully.');
}, function(err) {
  ui.log('err', err.stack || err);
  process.exit(1);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.install.resolveOnly" id="apidoc.element.jspm.install.resolveOnly">
        function <span class="apidocSignatureSpan">jspm.install.</span>resolveOnly
        <span class="apidocSignatureSpan">(pkg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolveOnly = function (pkg) {
  pkg = new PackageName(pkg);

  if (!pkg.version || !pkg.registry) {
    ui.log('warn', 'Resolve --only must take an exact package of the form `registry:pkg@version`.');
    return Promise.reject();
  }

  var didSomething = false;

  return config.load()
  .then(function() {
    Object.keys(config.loader.baseMap).forEach(function(name) {
      var curPkg = config.loader.baseMap[name];
      if (curPkg.registry === pkg.registry &amp;&amp; curPkg.package === pkg.package &amp;&amp; curPkg.version !== pkg.version) {
        didSomething = true;
        ui.log('info', 'Primary install ' + getUpdateRangeText(curPkg, pkg));
        config.loader.baseMap[name] = pkg.copy();
      }
    });

    Object.keys(config.loader.depMap).forEach(function(parent) {
      var curMap = config.loader.depMap[parent];
      Object.keys(curMap).forEach(function(name) {
        var curPkg = curMap[name];
        if (curPkg.registry === pkg.registry &amp;&amp; curPkg.package === pkg.package &amp;&amp; curPkg.version !== pkg.version) {
          didSomething = true;
          ui.log('info', 'In %' + parent + '% ' + getUpdateRangeText(curPkg, pkg));
          curMap[name] = pkg.copy();
        }
      });
    });

    return config.save();
  })
  .then(function() {
    if (didSomething)
      ui.log('ok', 'Resolution to only use `' + pkg.exactName + '` completed successfully.');
    else
      ui.log('ok', '`' + pkg.exactName + '` is already the only version of the package in use.');
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    case 'resolve':
options = readOptions(args, null, ['only']);

if (!options.only)
  return ui.log('warn', 'Use %jspm resolve --only registry:pkg@version%');

install.<span class="apidocCodeKeywordSpan">resolveOnly</span>(options.only)
.catch(function(err) {
  if (!err)
    ui.log('err', 'Resolve operation not performed.');
  else
    ui.log('err', err.stack || err);
  process.exit(1);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.install.showInstallGraph" id="apidoc.element.jspm.install.showInstallGraph">
        function <span class="apidocSignatureSpan">jspm.install.</span>showInstallGraph
        <span class="apidocSignatureSpan">(pkg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function showInstallGraph(pkg) {
  installed = installed || config.loader;
  pkg = new PackageName(pkg);
  var lastParent;
  var found;
  return loadExistingForkRanges(pkg, config.loader.local)
  .then(function() {
    ui.log('info', '\nInstalled versions of %' + pkg.name + '%');
    visitForkRanges(installed, pkg, null, null, function(name, parent, resolved, range) {
      found = true;
      if (range.version === '')
        range.version = '*';
      var rangeVersion = range.name === resolved.name ? range.version : range.exactName;
      if (range.version === '*')
        range.version = '';

      if (!parent)
        ui.log('info', '\n       %' + name + '% `' + resolved.version + '` (' + rangeVersion + ')');
      else {
        if (lastParent !== parent) {
          ui.log('info', '\n  ' + parent);
          lastParent = parent;
        }
        ui.log('info', '    ' + name + ' `' + resolved.version + '` (' + rangeVersion + ')');
      }
    });
    if (!found)
      ui.log('warn', 'Package `' + pkg.name + '` not found.');
    ui.log('');
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  config.load()
  .then(function() {
    if (!args[1])
      return install.showVersions(options.forks);
    if (!args[1].includes(':'))
      return ui.log('warn', 'Enter a full package name of the format `registry:repo`.');
    return install.<span class="apidocCodeKeywordSpan">showInstallGraph</span>(args[1]);
  })
  .catch(function(e) {
    ui.log('err', e.stack || e);
  });
  break;

case 'init':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.install.showVersions" id="apidoc.element.jspm.install.showVersions">
        function <span class="apidocSignatureSpan">jspm.install.</span>showVersions
        <span class="apidocSignatureSpan">(forks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function showVersions(forks) {
  installed = installed || config.loader;

  var versions = {};
  var haveLinked = false;
  var linkedVersions = {};

  function addDep(dep) {
    var vList = versions[dep.name] = versions[dep.name] || [];
    var version = dep.version;
    try {
      if (fs.readlinkSync(dep.getPath()))
        linkedVersions[dep.exactName] = true;
    }
    catch(e) {}
    if (vList.indexOf(version) === -1)
      vList.push(version);
  }

  Object.keys(installed.baseMap).forEach(function(dep) {
    addDep(installed.baseMap[dep]);
  });
  Object.keys(installed.depMap).forEach(function(parent) {
    var curMap = installed.depMap[parent];
    Object.keys(curMap).forEach(function(dep) {
      addDep(curMap[dep]);
    });
  });

  versions = alphabetize(versions);

  var vLen = Object.keys(versions).map(function(dep) {
    return dep.length;
  }).reduce(function(a, b) {
    return Math.max(a, b);
  }, 0);

  var shownIntro = false;

  Object.keys(versions).forEach(function(dep) {
    var vList = versions[dep].sort(semver.compare).map(function(version) {
      if (linkedVersions[dep + '@' + version]) {
        haveLinked = true;
        return '%' + version + '%';
      }
      else
        return '`' + version + '`';
    });

    if (forks &amp;&amp; vList.length === 1)
      return;

    if (!shownIntro) {
      ui.log('info', 'Installed ' + (forks ? 'Forks' : 'Versions') + '\n');
      shownIntro = true;
    }

    var padding = vLen - dep.length;
    var paddingString = '';
    while(padding--)
      paddingString += ' ';

    ui.log('info', '  ' + paddingString + '%' + dep + '% ' + vList.join(' '));
  });

  if (haveLinked) {
    ui.log('info', '\nBold versions are linked. To unlink use %jspm install --unlink [name]%.');
  }
  if (shownIntro) {
    ui.log('info', '\nTo inspect individual package constraints, use %jspm inspect registry:name%.\n');
  }
  else if (forks) {
    ui.log('ok', 'Install tree has no forks.');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    case 'inspect':
options = readOptions(args, ['forks']);
args = options.args;

config.load()
.then(function() {
  if (!args[1])
    return install.<span class="apidocCodeKeywordSpan">showVersions</span>(options.forks);
  if (!args[1].includes(':'))
    return ui.log('warn', 'Enter a full package name of the format `registry:repo`.');
  return install.showInstallGraph(args[1]);
})
.catch(function(e) {
  ui.log('err', e.stack || e);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.install.uninstall" id="apidoc.element.jspm.install.uninstall">
        function <span class="apidocSignatureSpan">jspm.install.</span>uninstall
        <span class="apidocSignatureSpan">(names)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uninstall = function (names) {
  if (!(names instanceof Array))
    names = [names];

  return config.load()
  .then(function() {
    installed = installed || config.loader;

    names.forEach(function(name) {
      if (!config.pjson.dependencies[name] &amp;&amp; !config.pjson.devDependencies[name])
        ui.log('warn', 'Dependency %' + name + '% is not an existing primary install.');

      delete config.pjson.dependencies[name];
      delete config.pjson.devDependencies[name];
      delete installed.baseMap[name];
    });

    return clean();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    case 'remove':
    case 'uninstall':
options = readOptions(args, ['yes']);

if (options.yes)
  ui.useDefaults();

install.<span class="apidocCodeKeywordSpan">uninstall</span>(options.args.splice(1))
.then(function() {
  ui.log('');
  ui.log('ok', 'Uninstall complete.');
}, function(err) {
  ui.log('err', err.stack || err);
  ui.log('warn', 'Uninstall changes not saved.');
  process.exit(1);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.link" id="apidoc.module.jspm.link">module jspm.link</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.link.link" id="apidoc.element.jspm.link.link">
        function <span class="apidocSignatureSpan">jspm.</span>link
        <span class="apidocSignatureSpan">(name, dir, force)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">link = function (name, dir, force) {
  var pjson, linkDir, pkg;

  return Promise.resolve()
  .then(function() {
    // try to get registry, package
    return readJSON(path.resolve(dir, 'package.json'));
  })
  .then(function(_pjson) {
    try {
      pkg = new PackageName(name);
    }
    catch(e) {
      pkg = {};
    }

    var packageName = pkg.package || _pjson.jspm &amp;&amp; _pjson.jspm.name || _pjson.name;
    var registry = pkg.registry || _pjson.jspm &amp;&amp; _pjson.jspm.registry || _pjson.registry;
    var version = pkg.version || _pjson.jspm &amp;&amp; _pjson.jspm.version || _pjson.version;

    if (!packageName)
      throw 'Package name not specified.';
    if (!registry)
      throw 'Package registry not specified.';
    if (!version)
      throw 'Package version not specified.';

    pkg = new PackageName(registry + ':' + packageName + '@' + version);

    return package.derivePackageConfig(pkg, _pjson);
  })
  .then(function(_pjson) {
    pjson = _pjson;

    linkDir = path.resolve(config.HOME, '.jspm', 'linked', pkg.registry, pkg.exactPackage);
    try {
      if (fs.existsSync(linkDir)) {
        return (force ? Promise.resolve(true) : ui.confirm('`' + pkg.exactName + '` is already linked, are you sure you want to
override it (use -y to skip this prompt in future)?', true))
        .then(function(override) {
          return !override;
        });
      }
    }
    catch(e) {}
  })
  // clear the directory
  .then(function(abort) {
    if (abort)
      return true;

    return asp(rimraf)(linkDir)
    // create it
    .then(function() {
      if (pjson.directories) {
        if (pjson.directories.lib) {
          dir = path.resolve(dir, pjson.directories.lib);
          delete pjson.directories.lib;
        }
        if (pjson.directories.dist) {
          dir = path.resolve(dir, pjson.directories.dist);
          delete pjson.directories.dist;
        }
      }

      return asp(mkdirp)(linkDir);
    })
    // copy the files to the local cache folder
    .then(function() {
      return asp(ncp)(dir, linkDir);
    })
    // run the jspm operations on the folder to process it
    .then(function() {
      return package.processPackage(pkg, linkDir, pjson, function() {});
    })
    .then(function() {
      return asp(fs.writeFile)(path.resolve(linkDir, '.jspm.json'), JSON.stringify(pjson, null, 2));
    });
  })
  .then(function(aborted) {
    if (!aborted)
      ui.log('ok', 'Package linked as `' + pkg.exactName + '`');
    else
      ui.log('info', 'Link operation aborted.');
  }, function(err) {
    ui.log('err', err.stack || err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ui.useDefaults();

args = options.args;

var linkname = args[2] || args[1] || '';
var linkpath = args[2] || '.';

link.<span class="apidocCodeKeywordSpan">link</span>(linkname, linkpath, options.force);
break;

    case 'registry':
options = readOptions(args, ['yes']);

if (options.yes)
  ui.useDefaults();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.link.lookup" id="apidoc.element.jspm.link.lookup">
        function <span class="apidocSignatureSpan">jspm.link.</span>lookup
        <span class="apidocSignatureSpan">(pkg, edge)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookup = function (pkg, edge) {
  var packageParts = pkg.package.split('/');
  var packagePart = packageParts.pop();
  var linkFolder = path.resolve(config.HOME, '.jspm', 'linked', pkg.registry, packageParts.join('/'));

  return asp(fs.readdir)(linkFolder)
  .then(function(files) {
    var versions = {};
    var hasVersions;
    files
    .filter(function(file) {
      return file.substr(0, file.lastIndexOf('@')) === packagePart;
    })
    .forEach(function(file) {
      hasVersions = true;
      versions[file.substr(file.lastIndexOf('@') + 1)] = { hash: 'hash' };
    });

    if (!hasVersions)
      throw 'No version match found for `' + pkg.exactName + '`';

    return function(version) {
      var lookupObj = package.getVersionMatch(version, versions, {edge: edge});
      if (!lookupObj)
        return;

      return pkg.copy().setVersion(lookupObj.version);
    };
  }, function(err) {
    if (err.code === 'ENOENT')
      throw 'No linked versions found for `' + pkg.name + '`';
    throw err;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function dl(name, repo, version) {
var pkg = new PackageName(repo);
var endpoint = registry.load(pkg.registry);
var vMatch, vMatchLookup;
var dlDir = path.resolve(loaderFilesCacheDir, name);

return endpoint.<span class="apidocCodeKeywordSpan">lookup</span>(pkg.package)
.then(function(lookup) {
  if (!(nodeSemver.validRange(version)))
    vMatch = version;
  else
    vMatch = Object.keys(lookup.versions)
    .filter(nodeSemver.valid)
    .sort(nodeSemver.compare).reverse()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.link.symlink" id="apidoc.element.jspm.link.symlink">
        function <span class="apidocSignatureSpan">jspm.link.</span>symlink
        <span class="apidocSignatureSpan">(pkg, downloadDeps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">symlink = function (pkg, downloadDeps) {
  var linkDir = path.resolve(config.HOME, '.jspm', 'linked', pkg.registry, pkg.exactPackage);
  var dir = path.resolve(config.pjson.packages, pkg.registry, pkg.exactPackage);
  var pjson;

  var fresh = false;

  return asp(fs.readlink)(dir)
  .then(function(linkString) {
    if (linkString === linkDir)
      return asp(fs.unlink)(dir);

    return Promise.resolve(ui.confirm('`' + pkg.exactName + '` already linked, are you sure you want to link over it?', true))
    .then(function(remove) {
      if (!remove)
        throw 'Aborted.';
      return asp(fs.unlink)(dir);
    });

  }, function(err) {
    if (err.code === 'ENOENT')
      return;
    if (err.code !== 'EINVAL' &amp;&amp; err.code !== 'UNKNOWN')
      throw err;

    return Promise.resolve(ui.confirm('`' + pkg.exactName + '` already installed, are you sure you want to link over it?', true))
    .then(function(remove) {
      if (!remove)
        throw 'Aborted.';
      return asp(rimraf)(dir);
    });
  })
  .then(function() {
    return asp(mkdirp)(path.resolve(dir, '..'))
    .then(function() {
      return asp(fs.symlink)(linkDir, dir, 'junction');
    })
    .then(function() {
      return readJSON(path.resolve(dir, '.jspm.json'));
    })
    .then(function(_pjson) {
      pjson = config.derivePackageConfig(_pjson);
      return package.createMain(pkg, pjson, dir);
    });
  })
  .then(function() {
    downloadDeps(package.processDeps(pjson.dependencies, pjson.registry));
    return fresh;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!resolution.registry)
  return;

// -- download --
return Promise.resolve()
.then(function() {
  if (options.link)
    return link.<span class="apidocCodeKeywordSpan">symlink</span>(resolution, downloadDeps);

  if (options.inject)
    return pkg.inject(resolution, downloadDeps);

  // override, quick, unlink options passed
  return pkg.download(resolution, options, downloadDeps);
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.loader" id="apidoc.module.jspm.loader">module jspm.loader</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.loader.loader" id="apidoc.element.jspm.loader.loader">
        function <span class="apidocSignatureSpan">jspm.</span>loader
        <span class="apidocSignatureSpan">(fileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Config(fileName) {
  this.__fileName = fileName;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.loader.prototype" id="apidoc.module.jspm.loader.prototype">module jspm.loader.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.loader.prototype.ensureRegistry" id="apidoc.element.jspm.loader.prototype.ensureRegistry">
        function <span class="apidocSignatureSpan">jspm.loader.prototype.</span>ensureRegistry
        <span class="apidocSignatureSpan">(registryName, remote)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureRegistry = function (registryName, remote) {
  var registries = this.registries;

  if (typeof remote === 'undefined') {
    // detect the registry mode from the first registry
    var registryKeys = Object.keys(registries);
    if (registryKeys.length &gt; 0) {
      remote = registries[registryKeys[0]].mode === 'remote';
    } else {
      remote = false;
    }
  }

  if (registries[registryName]) {
    if (remote)
      registries[registryName].setRemote();
    else
      registries[registryName].setLocal();
    return;
  }

  var ep = registries[registryName] = new RegistryPath(registryName);
  if (remote)
    ep.setRemote();
  else
    ep.setLocal();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return Promise.resolve(target);

return pkg.locate(target);
  })
  .then(function(located) {
target = located;

config.loader.<span class="apidocCodeKeywordSpan">ensureRegistry</span>(located.registry, options.inject);

if (options.link)
  return link.lookup(target, options.edge);

// lock if necessary
if (options.lock &amp;&amp; (resolution = getInstalledMatch(target, options.parent, name)))
  return Promise.resolve();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.loader.prototype.getConfig" id="apidoc.element.jspm.loader.prototype.getConfig">
        function <span class="apidocSignatureSpan">jspm.loader.prototype.</span>getConfig
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getConfig = function () {
  var cfg = extend({}, this.__originalConfig);

  // set all registry paths to be local paths
  cfg.paths = extend({}, cfg.paths);
  var registries = this.registries;
  for (var e in registries) {
    if (registries.hasOwnProperty(e))
      cfg.paths[e + ':*'] = registries[e].local;
  }
  return cfg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// jspm version of builder ignores config, baseURL arguments
// just allows cfg object
function Builder(_config) {
config.loadSync();
SystemJSBuilder.call(this, toFileURL(config.pjson.baseURL));

var cfg = config.loader.<span class="apidocCodeKeywordSpan">getConfig</span>();

if (cfg.depCache)
  delete cfg.depCache;
if (cfg.bundles)
  delete cfg.bundles;
if (cfg.baseURL)
  delete cfg.baseURL;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.loader.prototype.read" id="apidoc.element.jspm.loader.prototype.read">
        function <span class="apidocSignatureSpan">jspm.loader.prototype.</span>read
        <span class="apidocSignatureSpan">(prompts, sync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (prompts, sync) {
  if (this.__read)
    throw 'Config already read';
  this.__read = true;

  var self = this;
  var source;
  try {
    source = fs.readFileSync(this.__fileName);
  }
  catch(e) {
    source = '';
  }

  var cfg = {};
  var System = {
    config: function(_cfg) {
      for (var c in _cfg) {
        if (!_cfg.hasOwnProperty(c))
          continue;

        var v = _cfg[c];
        if (typeof v === 'object') {
          cfg[c] = cfg[c] || {};
          for (var p in v) {
            if (!v.hasOwnProperty(p))
              continue;
            cfg[c][p] = v[p];
          }
        }
        else
          cfg[c] = v;
      }
    },
    paths: {},
    map: {},
    versions: {}
  };
  eval(source.toString());

  // allow declarative form too
  var config = System.config;
  delete System.config;
  config(System);

  self.__originalConfig = cfg;

  self.baseURL = cfg.baseURL;

  self.defaultJSExtensions = true;

  if (cfg.transpiler === false)
    cfg.transpiler = 'none';

  // NB deprecate cfg.parser with 0.11.0
  self.transpiler = cfg.transpiler || cfg.parser || globalConfig.config.defaultTranspiler;

  // NB deprecate babel rename with 0.13
  if (self.transpiler === '6to5')
    self.transpiler = 'babel';

  self.babelOptions = cfg.babelOptions || {};
  self.traceurOptions = cfg.traceurOptions || {};
  self.typescriptOptions = cfg.typescriptOptions || {};

  // separate paths into registries and paths
  self.registries = {};
  self.paths = {};
  for (var p in cfg.paths) {
    if (p.match(registryRegEx)) {
      var registryName = p.substr(0, p.length - 2);
      var registryPath = new RegistryPath(registryName, cfg.paths[p]);
      self.registries[registryName] = registryPath;
      if (self.__local === undefined) {
        if (registryPath.mode === 'local')
          self.__local = true;
        else
          self.__local = false;
      }
    }
    // deprecate *: *.js
    else if (p === '*' &amp;&amp; cfg.paths[p] === '*.js') {
      delete cfg.paths[p];
      continue;
    }
  }
  self.paths = cfg.paths;

  self.shim = cfg.shim;
  self.bundles = cfg.bundles;
  self.depCache = cfg.depCache;

  // separate map into baseMap and depMap
  self.baseMap = {};
  self.depMap = {};
  for (var d in cfg.map) {
    if (typeof cfg.map[d] === 'string')
      self.baseMap[d] = new PackageName(cfg.map[d]);
    else {
      var depMap = cfg.map[d];
      self.depMap[d] = {};
      for (var m in depMap)
        if (depMap.hasOwnProperty(m)) {
          self.depMap[d][m] = new PackageName(depMap[m]);
        }
    }
  }

  // ensure that everything in baseMap has a depMap, even if empty
  var baseMap = self.baseMap, exactName;
  for (var n in baseMap) {
    if (baseMap.hasOwnProperty(n)) {
      exactName = baseMap[n].exactName;
      self.depMap[exactName] = self.depMap[exactName] || {};
    }
  }

  self.versions = self.versions || {};
  for (var v in cfg.versions) {
    if (typeof cfg.versions[v] === 'string')
      self.versions[v] = [cfg.versions[v]];
    else
      self.versions[v] = cfg.versions[v];
  }

  if (hasProperties(self.versions))
    upgradeToExactVersionResolution(self);


  if (!prompts)
    return;

  if (sync)
    throw 'Configuration file has not been initialized. Run jspm init first.';

  return ui.input('Enter client baseURL (public folder URL)', self.baseURL || '/')
  .then(function(baseURL) {
    self.baseURL = baseURL;

    return ui.confirm('Do you wish to use a transpiler?', true);
  })
  .then(function(useTranspiler) {
    if (!useTranspiler) {
      self.transpiler = 'none';
      return 'none';
    }

    return ui.input('Which ES6 transpiler would you like to use, %Babel%, %TypeScript% or %Traceur%?', self.transpiler);
  })
  .then(function(transpiler) {
    transpiler = transpiler.toLowerCase();

    if (transpiler !== 'babel' &amp;&amp; transpiler !== 'traceur' &amp;&amp; transpiler !== 'typescript' &amp;&amp; transpiler !== 'none')
      transpiler = globalConfig.config.defaultTranspiler;

    self.transpiler = transpiler;
    globalConfig.config.defaultTranspiler = transpiler;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      throw 'Operation aborted.';
  });
  })
  .then(function() {
config.pjsonPath = process.env.jspmConfigPath || path.resolve(process.cwd(), 'package.json');

config.pjson = new PackageConfig(config.pjsonPath);
return config.pjson.<span class="apidocCodeKeywordSpan">read</span>(prompts);
  })
  .then(function(_prompts) {
// package.json can indicate if we need to run config prompts for a new package
prompts = prompts || _prompts;

if (fs.existsSync(config.pjson.configFile))
  return;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.loader.prototype.write" id="apidoc.element.jspm.loader.prototype.write">
        function <span class="apidocSignatureSpan">jspm.loader.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  // extract over original config to keep initial values
  var cfg = extractObj(this, this.__originalConfig),
      cfgRegistries, cfgMap, cfgVersions;

  cfgRegistries = cfg.registries;
  for (var e in cfgRegistries) {
    if (!cfgRegistries.hasOwnProperty(e))
      continue;
    var val = cfgRegistries[e];
    delete cfgRegistries[e];
    cfgRegistries[e + ':*'] = val;
  }

  extend(cfg.paths, alphabetize(cfg.registries));
  delete cfg.registries;

  cfg.baseMap = alphabetize(cfg.baseMap);
  cfg.map = extend(cfg.baseMap, alphabetize(cfg.depMap));
  delete cfg.baseMap;
  delete cfg.depMap;

  cfgMap = cfg.map;
  for (var p in cfgMap) {
    if (!cfgMap.hasOwnProperty(p))
      continue;
    var subMap = cfgMap[p];
    if (typeof subMap === 'object') {
      if (!hasProperties(subMap))
        delete cfgMap[p];
      else
        cfgMap[p] = alphabetize(cfgMap[p]);
    }
  }

  cfgVersions = cfg.versions;
  for (var v in cfgVersions) {
    if (!cfgVersions.hasOwnProperty(v))
      continue;
    var version = cfgVersions[v];
    if (version.length === 1)
      cfgVersions[v] = version[0];
    if (version.length === 0)
      delete cfgVersions[v];
  }

  var outConfig = {};

  var meta = cfg.meta;
  var depCache = cfg.depCache;
  var map = cfg.map;
  var versions = alphabetize(cfg.versions);

  delete cfg.meta;
  delete cfg.depCache;
  delete cfg.map;
  delete cfg.versions;

  if (!hasProperties(cfg.babelOptions))
    delete cfg.babelOptions;
  if (!hasProperties(cfg.traceurOptions))
    delete cfg.traceurOptions;
  if (!hasProperties(cfg.typescriptOptions))
    delete cfg.typescriptOptions;

  if (cfg.bundles &amp;&amp; !hasProperties(cfg.bundles))
    delete cfg.bundles;

  if (hasProperties(cfg))
    extend(outConfig, cfg);

  cfg.meta = meta;
  cfg.depCache = depCache;
  cfg.map = map;
  cfg.versions = versions;

  if (hasProperties(meta))
    extend(outConfig, { meta: meta });

  if (hasProperties(depCache))
    extend(outConfig, { depCache: depCache });

  if (hasProperties(map))
    extend(outConfig, { map: map });

  if (outConfig.transpiler === 'none')
    outConfig.transpiler = false;

  var configContent = stringify(outConfig)
      // add a newline before "meta", "depCache", "map" blocks, removing quotes
      .replace(new RegExp('^' + config.tab + '"(meta|depCache|map|packages)"', 'mg'), config.newLine + config.tab + '$1')
      // remove quotes on first-level letter-based properties
      .replace(new RegExp('^' + config.tab + '"(\\w+)"', 'mg'), config.tab + '$1');

  return asp(fs.writeFile)(this.__fileName, 'System.config(' + configContent + ');' + config.newLine);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return ui.log('warn', 'You must provide an registry name to export.');
  if (!globalConfig.config.registries[args[2]])
    return ui.log('warn', 'Registry %' + args[2] + '% does not exist.');

  var registryConfig = globalConfig.config.registries[args[2]];

  dwalk(registryConfig, function(p, value) {
    process.stdout.<span class="apidocCodeKeywordSpan">write</span>('jspm config registries.' + args[2] + '.'
; + p + ' ' + value + '\n');
  });
}
else {
  showInstructions();
  ui.log('warn', 'Invalid registry argument %' + args[1] + '%.');
}
break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.package" id="apidoc.module.jspm.package">module jspm.package</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.package.createMain" id="apidoc.element.jspm.package.createMain">
        function <span class="apidocSignatureSpan">jspm.package.</span>createMain
        <span class="apidocSignatureSpan">(pkg, pjson, downloadDir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createMain = function (pkg, pjson, downloadDir) {
  var lastNamePart, main;
  var mainPath;
  var pluginMain;

  return Promise.resolve()

  // create the main entry point
  .then(function() {
    lastNamePart = pkg.name.split('/').pop().split(':').pop();
    main = typeof pjson.main === 'string' &amp;&amp; pjson.main;

    // we don't need to ensure it exists for plugin mains
    // as they can have custom locate functions
    if (main &amp;&amp; main.indexOf('!') !== -1) {
      pluginMain = true;
      return true;
    }

    if (!main)
      return false;

    if (main.startsWith('./')) {
      main = main.substr(2);
    }

    return new Promise(function(resolve) {
      // Check to see if main points to an actual file or not
      // i.e. does it include extension.
      mainPath = path.resolve(downloadDir, main);
      fs.exists(mainPath, resolve);
    });
  })
  .then(function(exists) {
    main = main || 'index';

    return new Promise(function(resolve) {
      // `main` does not have extension (or it does not point to an actual file).
      // Try again with `.js` extension
      mainPath = path.resolve(downloadDir, main + '.js');
      fs.exists(mainPath, resolve);
    })
    .then(function(_exists) {
      if (!_exists)
        mainPath = path.resolve(downloadDir, main);
      return exists || _exists;
    });
  })
  .then(function(exists) {
    if (exists)
      return exists;

    main = lastNamePart;

    if (main.endsWith('.js'))
      main = main.substr(0, main.length - 3);

    return new Promise(function(resolve) {
      mainPath = path.resolve(downloadDir, main + '.js');
      fs.exists(mainPath, resolve);
    });
  })
  .then(function(exists) {
    // don't create a main if it doesn't exist
    if (!exists) {
      if (pjson.main !== false)
        ui.log('warn', 'Main entry point not found for `' + pkg.exactName + '`.\nAdjust this property in the package.json or with
 an override, setting %"main": false% if this is the intention.\n');
      return;
    }

    // create the main pointer
    var mainFile = path.resolve(downloadDir, '../' + lastNamePart + '@' + pkg.version + '.js');

    // plugin mains are redirected by CommonJS
    if (pluginMain)
      return asp(fs.writeFile)(mainFile, getRedirectContents('cjs', pkg.exactName + '/' + main));

    // otherwise detect the format of the main
    return asp(fs.readFile)(mainPath)
    .catch(function(err) {
      if (err.code == 'EISDIR')
        return;
      throw err;
    })
    .then(function(source) {
      if (typeof source == 'undefined')
        return;
      var format = pjson.format || build.detectFormat(source.toString()).format;

      return asp(fs.writeFile)(mainFile, getRedirectContents(format, pkg.exactName + '/' + main));
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return asp(fs.symlink)(linkDir, dir, 'junction');
    })
    .then(function() {
      return readJSON(path.resolve(dir, '.jspm.json'));
    })
    .then(function(_pjson) {
      pjson = config.derivePackageConfig(_pjson);
      return package.<span class="apidocCodeKeywordSpan">createMain</span>(pkg, pjson, dir);
    });
  })
  .then(function() {
    downloadDeps(package.processDeps(pjson.dependencies, pjson.registry));
    return fresh;
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.package.derivePackageConfig" id="apidoc.element.jspm.package.derivePackageConfig">
        function <span class="apidocSignatureSpan">jspm.package.</span>derivePackageConfig
        <span class="apidocSignatureSpan">(pkg, pjson, override)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function derivePackageConfig(pkg, pjson, override) {
  pjson = config.derivePackageConfig(pjson, override);

  var endpoint = registry.load(pjson.registry || pkg.registry);
  return Promise.resolve(endpoint.processPackageConfig ? endpoint.processPackageConfig(pjson, pkg.exactName) : pjson)
  .then(function(pjson) {
    if (!pjson)
      throw new Error('processPackageConfig must return the processed package.json object.');
    pjson.registry = pjson.registry || pkg.registry;
    return pjson;
  })
  .catch(function() {
    throw 'Error processing package config for `' + pkg.name + '`.';
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!registry)
  throw 'Package registry not specified.';
if (!version)
  throw 'Package version not specified.';

pkg = new PackageName(registry + ':' + packageName + '@' + version);

return package.<span class="apidocCodeKeywordSpan">derivePackageConfig</span>(pkg, _pjson);
  })
  .then(function(_pjson) {
pjson = _pjson;

linkDir = path.resolve(config.HOME, '.jspm', 'linked', pkg.registry, pkg.exactPackage);
try {
  if (fs.existsSync(linkDir)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.package.download" id="apidoc.element.jspm.package.download">
        function <span class="apidocSignatureSpan">jspm.package.</span>download
        <span class="apidocSignatureSpan">(pkg, options, installDeps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">download = function (pkg, options, installDeps) {
  var sentDeps;
  // called twice, ensure we don't duplicate install requests back
  function depsCallback(depRanges) {
    if (sentDeps)
      Object.keys(depRanges).forEach(function(dep) {
        if (sentDeps.indexOf(dep) != -1)
          delete depRanges[dep];
      });
    else
      sentDeps = Object.keys(depRanges);
    if (installDeps)
      installDeps(depRanges);
    return depRanges;
  }

  // download queue
  if (downloading[pkg.exactName]) {
    downloading[pkg.exactName].preload.then(depsCallback);
    downloading[pkg.exactName].postload.then(depsCallback);
    return downloading[pkg.exactName].promise;
  }
  var postloadResolve, preloadResolve;
  downloading[pkg.exactName] = {
    preload: new Promise(function(resolve) {
      preloadResolve = resolve;
    })
    .then(depsCallback),
    postload: new Promise(function(resolve) {
      postloadResolve = resolve;
    })
    .then(depsCallback)
  };

  // download
  var override = options.override;
  var downloadDir = pkg.getPath();
  var getPackageConfigPromise;

  downloading[pkg.exactName].promise = Promise.resolve()
  .then(function() {
    // if we have no constraint information, it's immediately a not-found
    if (!config.deps[pkg.exactName])
      return { notfound: true };

    // otherwise check the folder info
    return getPackageDirInfo(downloadDir);
  })
  .then(function(dirInfo) {
    if (dirInfo.linked &amp;&amp; !options.unlink)
      return preloadResolve(config.deps[pkg.exactName]);

    var cacheDir = path.resolve(config.HOME, '.jspm', 'packages', pkg.registry, pkg.exactPackage);

    var endpoint = registry.load(pkg.registry);

    var hash;
    var fullHash;
    var meta;

    var fresh;

    return (options.quick &amp;&amp; dirInfo.hash ? Promise.resolve(true) : Promise.all([
      // ensure we have the hash from the lookup
      _pkg.lookup(pkg, options.edge)
      .then(function() {
        var lookupObj = lookups[pkg.package][pkg.version];
        if (!lookupObj &amp;&amp; !options.link)
          throw 'Unable to resolve version %' + pkg.version + '% for `' + pkg.package + '`.';

        if (lookupObj) {
          hash = lookupObj.hash;
          meta = lookupObj.meta;
        }
        // linked packages have no lookup object
        else {
          hash = '';
          meta = {};
        }
      }),

      // and the override
      Promise.resolve()
      .then(function() {
        // load the registry endpoint
        var endpoint = registry.load(globalConfig.config.defaultRegistry);

        // get the override
        if (endpoint.getOverride) {
          if (!override) {
            var overrideVersion = Object.keys(config.pjson.overrides)
            .filter(function(overrideName) {
              return overrideName.startsWith(pkg.name + '@');
            })
            .map(function(overrideName) {
              return overrideName.split('@').pop();
            })
            .filter(function(overrideVersion) {
              return semver.match('^' + overrideVersion, pkg.version);
            })
            .sort(semver.compare).pop();
            if (overrideVersion) {
              override = config.pjson.overrides[pkg.name + '@' + overrideVersion];
              ui.log('warn', 'Using local override for `' + pkg.exactName + '`');
            }
          }
          return endpoint.getOverride(pkg.registry, pkg.package, pkg.version, override);
        }

        return override;
      })
      .then(function(_override) {
        override = _override;
      })
    ]))
    .then(function() {
      if (options.quick &amp;&amp; dirInfo.hash)
        return true;

      // create the full package hash by combining it with the override and registry code hash
      fullHash = hash + md5(JSON.stringify(override || {})) + endpoint.versionString + jspmVersion + '.1';

      if (config.force)
        return false;

      return dirInfo.hash === fullHash;
    })
    .then(function(_fresh) {
      fresh = _fresh;
      if (fresh) {
        // this can't trigger twice, so if its a second call its just a noop
        preloadResolv ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    throw e;
  });
})
.then(function(cached) {
  if (cached)
    return;

  return endpoint.<span class="apidocCodeKeywordSpan">download</span>(pkg.package, vMatch, vMatchLookup.hash, vMatchLookup.meta,
dlDir)
  .then(function() {
    return fs.writeFile(path.resolve(dlDir, '.hash'), vMatchLookup.hash);
  });
})
.then(function() {
  return vMatch;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.package.getVersionMatch" id="apidoc.element.jspm.package.getVersionMatch">
        function <span class="apidocSignatureSpan">jspm.package.</span>getVersionMatch
        <span class="apidocSignatureSpan">(pkgVersion, versions, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getVersionMatch(pkgVersion, versions, options) {
  // unescape pkgVersion for comparison
  if (pkgVersion)
    pkgVersion = decodeURIComponent(pkgVersion);

  var version;
  var stableSemver = [];
  var unstableSemver = [];
  var stableExact = [];
  var unstableExact = [];
  var edge = options &amp;&amp; options.edge;

  Object.keys(versions).forEach(function(v) {
    version = versions[v];
    var stable = version.stable;
    var semverMatch = v.match(semver.semverRegEx);
    var valid = semverMatch &amp;&amp; semverMatch[1] &amp;&amp; semverMatch[2] &amp;&amp; semverMatch[3];
    var pre = valid &amp;&amp; semverMatch[4];

    // store a reverse lookup
    version.version = v;

    // ignore non-semver or prerelease, unless explictly marked as stable
    if (!valid) {
      // unstable unless explicitly stable. in --edge prioritize all after 'master'
      if (stable &amp;&amp; !edge)
        stableExact.push(v);
      else
        unstableExact.push(v);
    }
    // stable unless explicitly unstable or indetermate and a prerelease
    // --edge considers all semver to be stable
    else if (!edge &amp;&amp; (stable === false || (stable !== true &amp;&amp; pre)))
      unstableSemver.push(v);
    else
      stableSemver.push(v);
  });

  function compareDesc(a, b) {
    return semver.compare(b, a);
  }

  if (!pkgVersion) {
    var latest = options &amp;&amp; options.latestVersion &amp;&amp; versions[options.latestVersion];
    if (!edge &amp;&amp; latest)
      return latest;
    stableSemver.sort(compareDesc);

    if (stableSemver[0])
      return versions[stableSemver[0]];

    unstableSemver.sort(compareDesc);
    if (unstableSemver[0])
      return versions[unstableSemver[0]];

    if (latest)
      return latest;

    stableExact.sort();
    if (stableExact[0])
      return versions[stableExact[0]];

    // an ugly practicality. ideally designed out in future.
    if (versions.master)
      return versions.master;

    unstableExact.sort();
    if (unstableExact[0])
      return versions[unstableExact[0]];
  }
  else {
    var i, ver;
    stableSemver.sort(compareDesc);
    // find highest stable match in tags
    for (i = 0; i &lt; stableSemver.length; i++) {
      ver = stableSemver[i];
      var match = edge ? semver.matchUnstable : semver.match;
      if (match(pkgVersion, ver))
        return versions[ver];
    }
    unstableSemver.sort(compareDesc);
    for (i = 0; i &lt; unstableSemver.length; i++) {
      ver = unstableSemver[i];
      if (semver.match(pkgVersion, ver))
        return versions[ver];
    }
    // finally check for an exact tag match
    if (versions[pkgVersion])
      return versions[pkgVersion];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    versions[file.substr(file.lastIndexOf('@') + 1)] = { hash: 'hash' };
  });

  if (!hasVersions)
    throw 'No version match found for `' + pkg.exactName + '`';

  return function(version) {
    var lookupObj = package.<span class="apidocCodeKeywordSpan">getVersionMatch</span>(version, versions, {edge: edge});
    if (!lookupObj)
      return;

    return pkg.copy().setVersion(lookupObj.version);
  };
}, function(err) {
  if (err.code === 'ENOENT')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.package.inject" id="apidoc.element.jspm.package.inject">
        function <span class="apidocSignatureSpan">jspm.package.</span>inject
        <span class="apidocSignatureSpan">(pkg, depLoad)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inject = function (pkg, depLoad) {
  if (injecting[pkg.exactName]) {
    injecting[pkg.exactName].depLoad.then(function(depMap) {
      depLoad(depMap);
      return depMap;
    });
    return injecting[pkg.exactName].promise;
  }

  injecting[pkg.exactName] = {};

  var depResolve, depReject;
  injecting[pkg.exactName].depLoad = new Promise(function(resolve, reject) {
    depResolve = resolve;
    depReject = reject;
  })
  .then(function(depMap) {
    depLoad(depMap);
    return depMap;
  });

  var remote = registry.load(pkg.registry).remote;

  if (!remote)
    throw 'Cannot inject from registry %' + pkg.registry + '% as it has no remote.';

  // NB remove rejectUnauthorized
  var url = remote + (remote.endsWith('/') ? '' : '/') + pkg.exactName.substr(pkg.exactName.indexOf(':') + 1) + '/.jspm.json';
  injecting[pkg.exactName].promise = asp(request)({
    method: 'get',
    url: url,
    rejectUnauthorized: false
  }).then(function(res) {
    if (res.statusCode !== 200)
      throw new Error('Error requesting package.json for `' + pkg.exactName + '` at %' + url + '%.');

    try {
      return JSON.parse(res.body);
    }
    catch(e) {
      throw new Error('Unable to parse package.json');
    }
  })
  .then(function(pjson) {
    depResolve(processDeps(pjson.dependencies, pjson.registry));
    return pjson;
  }, depReject);
  return injecting[pkg.exactName].promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// -- download --
return Promise.resolve()
.then(function() {
  if (options.link)
    return link.symlink(resolution, downloadDeps);

  if (options.inject)
    return pkg.<span class="apidocCodeKeywordSpan">inject</span>(resolution, downloadDeps);

  // override, quick, unlink options passed
  return pkg.download(resolution, options, downloadDeps);
})
.then(function(fresh) {
  resolution.fresh = fresh;
  // log sub-dependencies before child completion for nicer output
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.package.locate" id="apidoc.element.jspm.package.locate">
        function <span class="apidocSignatureSpan">jspm.package.</span>locate
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">locate = function (target) {
  if (!target.registry) {
    target = new PackageName(target.exactName);
    target.setRegistry(globalConfig.config.defaultRegistry);
  }

  var endpoint = registry.load(target.registry);

  if (!endpoint.locate)
    return Promise.resolve(target);

  locateCache[target.registry] = locateCache[target.registry] || {};

  // NB enable versioned locate
  return Promise.resolve()
  .then(function() {
    if (locateCache[target.registry][target.package])
      return locateCache[target.registry][target.package];

    return (locateCache[target.registry][target.package] = Promise.resolve(endpoint.locate(target.package))
    .then(function(located) {
      // NB support versioned registry
      if (target.registry === globalConfig.config.defaultRegistry)
        registryCache[target.package] = located.redirect;
      return located;
    }));
  })
  .then(function(located) {
    if (!located)
      return target;

    if (located.redirect) {
      var newTarget = new PackageName(located.redirect);
      newTarget.setVersion(target.version);
      return _pkg.locate(newTarget);
    }

    if (located.notfound)
      throw 'Repo `' + target.name + '` not found.' +
        (target.registry != 'npm' &amp;&amp; target.package.split('/').length == 1 ? ' Perhaps try %jspm install npm:' + target.package + '%.' : '');

    throw 'Invalid registry locate response for %' + target.registry + '%';
  }, function() {
    throw 'Error locating `' + target.name + '`.';
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var existing;

  return Promise.resolve()
  .then(function() {
if (options.link)
  return Promise.resolve(target);

return pkg.<span class="apidocCodeKeywordSpan">locate</span>(target);
  })
  .then(function(located) {
target = located;

config.loader.ensureRegistry(located.registry, options.inject);

if (options.link)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.package.lookup" id="apidoc.element.jspm.package.lookup">
        function <span class="apidocSignatureSpan">jspm.package.</span>lookup
        <span class="apidocSignatureSpan">(pkg, edge)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookup = function (pkg, edge) {
  return Promise.resolve()

  // load the version map
  .then(function() {
    if (lookupPromises[pkg.package])
      return lookupPromises[pkg.package];

    ui.log('info', 'Looking up `' + pkg.name + '`');

    lookupPromises[pkg.package] = Promise.resolve(registry.load(pkg.registry).lookup(pkg.package));
    return lookupPromises[pkg.package];
  })
  .then(function(lookup) {
    if (lookup.notfound)
      throw 'Repo `' + pkg.name + '` not found!';

    if (!lookup.versions)
      throw 'Invalid registry lookup response for %' + pkg.registry + '%';

    lookups[pkg.package] = lookup.versions;

    return function(version) {
      var opts = {edge: edge, latestVersion: lookup.latest};
      var lookupObj = getVersionMatch(version, lookup.versions, opts);
      if (!lookupObj)
        return;

      return new PackageName(pkg.name + '@' + lookupObj.version, true);
    };
  }, function() {
    throw 'Error looking up `' + pkg.name + '`.';
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function dl(name, repo, version) {
var pkg = new PackageName(repo);
var endpoint = registry.load(pkg.registry);
var vMatch, vMatchLookup;
var dlDir = path.resolve(loaderFilesCacheDir, name);

return endpoint.<span class="apidocCodeKeywordSpan">lookup</span>(pkg.package)
.then(function(lookup) {
  if (!(nodeSemver.validRange(version)))
    vMatch = version;
  else
    vMatch = Object.keys(lookup.versions)
    .filter(nodeSemver.valid)
    .sort(nodeSemver.compare).reverse()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.package.processDeps" id="apidoc.element.jspm.package.processDeps">
        function <span class="apidocSignatureSpan">jspm.package.</span>processDeps
        <span class="apidocSignatureSpan">(deps, registry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function processDeps(deps, registry) {
  var outdeps = {};
  if (!deps)
    return outdeps;
  Object.keys(deps).forEach(function(p) {
    var dep = deps[p];

    if (dep instanceof PackageName) {
      outdeps[p] = dep;
      return outdeps[p];
    }

    var outPackage;

    // jquery: github:components/jquery
    // jquery: jquery@1.5
    // -&gt; RHS is dep
    if (dep.indexOf(':') !== -1)
      outPackage = dep;

    else if (!registry)
      throw new TypeError('Install of %' + p + '% to `' + dep + '` has no registry property provided.');

    // jquery: components/jquery@1.5
    else if (dep.lastIndexOf('@') &gt; 0)
      outPackage = registry + ':' + dep;

    // jquery: 1.5
    else
      outPackage = registry + ':' + p + '@' + dep;

    outdeps[p] = new PackageName(outPackage, true);
  });
  return outdeps;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
else if (targets &amp;&amp; options.update)
  for (d in targets) {
    if (!existingTargets[d])
      throw '%' + d + '% is not an existing dependency to update.';
    targets[d] = existingTargets[d];
  }

targets = pkg.<span class="apidocCodeKeywordSpan">processDeps</span>(targets, globalConfig.config.defaultRegistry);

return Promise.all(Object.keys(targets).map(function(name) {
  return install(name, targets[name], options);
}))
.then(function() {
  return saveInstall();
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.package.processPackage" id="apidoc.element.jspm.package.processPackage">
        function <span class="apidocSignatureSpan">jspm.package.</span>processPackage
        <span class="apidocSignatureSpan">(pkg, dir, pjson, postload, isCDN)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processPackage = function (pkg, dir, pjson, postload, isCDN) {
  // any package which takes longer than 10 seconds to process
  var timeout = setTimeout(function() {
    ui.log('warn', 'It\'s taking a long time to process the dependencies of `' + pkg.exactName + '`.\n' +
      'This package may need an %ignore% property to indicate test or example folders for jspm to skip.\n');
  }, 10000);
  var endpoint = registry.load(pjson.registry || pkg.registry);
  var deps;
  var buildErrors = [];
  var curDeps = [];

  return Promise.resolve()

  .then(function() {
    // now that we have the derived pjson, do the registry build
    if (endpoint.build)
      return Promise.resolve()
      .then(function() {
        curDeps = pjson.dependencies &amp;&amp; Object.keys(pjson.dependencies) || [];
        return endpoint.build(pjson, dir);
      })
      .catch(function() {
        throw 'Error building package `' + pkg.name + '`.';
      });
  })

  // apply build operations from the package.json
  .then(function(_buildErrors) {
    if (_buildErrors)
      buildErrors = buildErrors.concat(_buildErrors);

    // if we gained a new dependency, download it
    postload(getDepRanges(pjson));

    // don't build in dependencies
    if (!isCDN) {
      deps = pjson.dependencies;
      delete pjson.dependencies;
    }
    else {
      deps = pjson.dependencies;
      pjson.dependencies = processDeps(pjson.dependencies, pjson.registry);
    }

    return build.buildPackage(dir, pjson, isCDN);
  })

  // save the final calculated package.json in place
  .then(function(_buildErrors) {
    if (_buildErrors)
      buildErrors = buildErrors.concat(_buildErrors);
    pjson.dependencies = deps;
  })
  .then(function() {
    // write build errors
    if (buildErrors.length)
      return asp(fs.writeFile)(path.resolve(dir, '.jspm.errors'), buildErrors.join('\n\n'));
  })
  .then(function() {
    clearTimeout(timeout);
    return pjson;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  })
  // copy the files to the local cache folder
  .then(function() {
    return asp(ncp)(dir, linkDir);
  })
  // run the jspm operations on the folder to process it
  .then(function() {
    return package.<span class="apidocCodeKeywordSpan">processPackage</span>(pkg, linkDir, pjson, function() {});
  })
  .then(function() {
    return asp(fs.writeFile)(path.resolve(linkDir, '.jspm.json'), JSON.stringify(pjson, null, 2));
  });
})
.then(function(aborted) {
  if (!aborted)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.package_name" id="apidoc.module.jspm.package_name">module jspm.package_name</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.package_name.package_name" id="apidoc.element.jspm.package_name.package_name">
        function <span class="apidocSignatureSpan">jspm.</span>package_name
        <span class="apidocSignatureSpan">(name, escape)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Package(name, escape) {
  this.exactName = name;

  if (name.indexOf(':') !== -1)
    this.registry = name.split(':')[0];

  var pkg = this.registry ? name.substr(this.registry.length + 1) : name;

  var versionIndex = pkg.lastIndexOf('@');
  var version = '';

  if (versionIndex !== -1 &amp;&amp; versionIndex !== 0) {
    version = pkg.substr(versionIndex + 1);
    pkg = pkg.substr(0, versionIndex);
  }

  if (escape &amp;&amp; version)
    version = version.replace(/[\/%]/g, function(symbol) {
      return encodeURIComponent(symbol);
    });

  this.package = pkg;

  this.name = (this.registry ? this.registry + ':' : '') + this.package;

  this.setVersion(version);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.package_name.prototype" id="apidoc.module.jspm.package_name.prototype">module jspm.package_name.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.package_name.prototype.copy" id="apidoc.element.jspm.package_name.prototype.copy">
        function <span class="apidocSignatureSpan">jspm.package_name.prototype.</span>copy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copy = function () {
  return new Package(this.exactName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return resolution.version;
    }

    // alter this secondary install to the other primary or secondary
    if (!consolidated &amp;&amp; options.parent &amp;&amp; semver.match(target.version, forkVersion)) {
      consolidated = true;
      if (forkVersion !== resolution.version) {
        var newResolution = resolution.<span class="apidocCodeKeywordSpan">copy</span>().setVersion(forkVersion);
        logResolution(installingResolves, resolution, newResolution);
        resolution = newResolution;
      }
    }
  });

// c. Forks against the existing tree are handled by upgrading the existing tree,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.package_name.prototype.getPath" id="apidoc.element.jspm.package_name.prototype.getPath">
        function <span class="apidocSignatureSpan">jspm.package_name.prototype.</span>getPath
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPath = function () {
  return path.resolve(config.pjson.packages, this.registry, this.exactPackage);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var haveLinked = false;
var linkedVersions = {};

function addDep(dep) {
  var vList = versions[dep.name] = versions[dep.name] || [];
  var version = dep.version;
  try {
    if (fs.readlinkSync(dep.<span class="apidocCodeKeywordSpan">getPath</span>()))
      linkedVersions[dep.exactName] = true;
  }
  catch(e) {}
  if (vList.indexOf(version) === -1)
    vList.push(version);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.package_name.prototype.setRegistry" id="apidoc.element.jspm.package_name.prototype.setRegistry">
        function <span class="apidocSignatureSpan">jspm.package_name.prototype.</span>setRegistry
        <span class="apidocSignatureSpan">(registry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setRegistry = function (registry) {
  if (this.registry)
    throw 'Endpoint already set.';
  this.registry = registry;
  this.exactName = registry + ':' + this.exactName;
  this.name = registry + ':' + this.name;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// getting 'github:components/jquery' and 'github:repo/redirected'
// at this point, we have the final name for the target
var locateCache = {};
// target is a PackageName object
exports.locate = function(target) {
if (!target.registry) {
  target = new PackageName(target.exactName);
  target.<span class="apidocCodeKeywordSpan">setRegistry</span>(globalConfig.config.defaultRegistry);
}

var endpoint = registry.load(target.registry);

if (!endpoint.locate)
  return Promise.resolve(target);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.package_name.prototype.setVersion" id="apidoc.element.jspm.package_name.prototype.setVersion">
        function <span class="apidocSignatureSpan">jspm.package_name.prototype.</span>setVersion
        <span class="apidocSignatureSpan">(version)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setVersion = function (version) {
  if (version === '*')
    version = '';
  this.version = version;
  var v = this.version ? '@' + this.version : '';
  this.exactPackage = this.package + v;
  this.exactName = this.name + v;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  else
    throw 'No version match found for `' + target.exactName + '`';
}

// if no version range was specified on install, install to semver-compatible with the latest
if (!options.parent &amp;&amp; !target.version &amp;&amp; !options.link) {
  if (resolution.version.match(semver.semverRegEx))
    target.<span class="apidocCodeKeywordSpan">setVersion</span>('^' + resolution.version);
  else
    target.setVersion(resolution.version);
}
else if (options.edge &amp;&amp; !options.parent &amp;&amp; !options.link) {
  // use strictest compatible semver range if installing --edge without target, or
  // with a range that does not include the resolved version
  if (!target.version || !semver.match(target.version, resolution.version)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.package_name.prototype.write" id="apidoc.element.jspm.package_name.prototype.write">
        function <span class="apidocSignatureSpan">jspm.package_name.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  return this.exactName;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return ui.log('warn', 'You must provide an registry name to export.');
  if (!globalConfig.config.registries[args[2]])
    return ui.log('warn', 'Registry %' + args[2] + '% does not exist.');

  var registryConfig = globalConfig.config.registries[args[2]];

  dwalk(registryConfig, function(p, value) {
    process.stdout.<span class="apidocCodeKeywordSpan">write</span>('jspm config registries.' + args[2] + '.'
; + p + ' ' + value + '\n');
  });
}
else {
  showInstructions();
  ui.log('warn', 'Invalid registry argument %' + args[1] + '%.');
}
break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.registry" id="apidoc.module.jspm.registry">module jspm.registry</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.registry.configure" id="apidoc.element.jspm.registry.configure">
        function <span class="apidocSignatureSpan">jspm.registry.</span>configure
        <span class="apidocSignatureSpan">(registry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (registry) {
  var registryConfig = globalConfig.config.registries[registry] || {},
      RegistryClass;

  if (!registryConfig.handler)
    throw 'Registry %' + registry + '% not found.';

  var handler = registryConfig.handler;
  delete registryConfig.handler;

  try {
    RegistryClass = require(handler);
  }
  catch(e) {
    throw 'Registry handler `' + handler + '` not installed.';
  }

  registryConfig.name = registry;
  registryConfig.strictSSL = globalConfig.config.strictSSL;

  return Promise.resolve(RegistryClass.configure &amp;&amp; RegistryClass.configure(registryConfig, ui) || registryConfig)
  .then(function(_config) {
    delete _config.name;
    delete _config.strictSSL;
    _config.handler = handler;
    globalConfig.config.registries[registry] = _config;
  })
  .then(function() {
    globalConfig.save();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ui.useDefaults();

var action = args[1];

if (action === 'config') {
  if (!args[2])
    return ui.log('warn', 'You must provide an registry name to configure.');
  return Promise.resolve(registry.<span class="apidocCodeKeywordSpan">configure</span>(args[2]))
  .then(function() {
    ui.log('ok', 'Registry %' + args[2] + '% configured successfully.');
  }, function(err) {
    ui.log('err', err.stack || err);
  });
}
else if (action === 'create') {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.registry.create" id="apidoc.element.jspm.registry.create">
        function <span class="apidocSignatureSpan">jspm.registry.</span>create
        <span class="apidocSignatureSpan">(name, handler, override)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (name, handler, override) {

  // handle override prompts etc
  if (!override &amp;&amp; globalConfig.config.registries[name]) {
    if (globalConfig.config.registries[name].handler === handler)
      return ui.confirm('Registry %' + name + '% already exists. Do you want to reconfigure it now?')
      .then(function(configure) {
        if (configure)
          return Promise.resolve(exports.configure(name))
          .then(function() {
            ui.log('ok', 'Registry %' + name + '% configured successfully.');
            return false;
          });
        else
          return false;
      });
    else
      return ui.confirm('Registry %' + name + '% already exists, but based on `' + globalConfig.config.registries[name].handler + '`.
Are you sure you want to override it?')
      .then(function(override) {
        if (override)
          return Promise.resolve(exports.create(name, handler, true));
        return false;
      });
  }

  var registryConfig = globalConfig.config.registries[name] = globalConfig.config.registries[name] || {};
  registryConfig.handler = handler;

  // load the registry and configure it
  return exports.configure(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
}
else if (action === 'create') {
  if (!args[2])
    return ui.log('warn', 'You must provide an registry name to create.');
  if (!args[3])
    return ui.log('warn', 'You must provide the registry module name to generate from.');
  return Promise.resolve(registry.<span class="apidocCodeKeywordSpan">create</span>(args[2], args[3]))
  .then(function(created) {
    if (created)
      ui.log('ok', 'Enpoint %' + args[2] + '% created successfully.');
  }, function(err) {
    ui.log('err', err.stack || err);
  });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.registry.load" id="apidoc.element.jspm.registry.load">
        function <span class="apidocSignatureSpan">jspm.registry.</span>load
        <span class="apidocSignatureSpan">(registry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (registry) {
  if (registryClasses[registry])
    return registryClasses[registry];

  try {
    // ensure the tmpDir exists
    var tmpDir = path.resolve(config.HOME, '.jspm', registry + '-cache');
    if (!fs.existsSync(tmpDir))
      fs.mkdirSync(tmpDir);

    var options = dextend({
      timeouts: {
        lookup: 60,
        download: 300,
        build: 120
      },
      tmpDir: tmpDir,
      apiVersion: '1.6'
    }, globalConfig.config.registries[registry] || {});

    options.name = registry;
    if (globalConfig.config.strictSSL === false || globalConfig.config.strictSSL == 'false')
      options.strictSSL = false;

    if (!options.handler)
      throw 'Registry %' + registry + '% not found.';

    var RegistryClass = require(options.handler);
    var registryPackageJSON = require(options.handler + '/package.json');
    var versionString = registryPackageJSON.name + '@' + registryPackageJSON.version.split('.').splice(0, 2).join('.');
    options.versionString = versionString;

    var registryInstance = registryClasses[registry] = new RegistryClass(options, ui);
    registryInstance.constructor = RegistryClass;

    var timeoutLookup = options.timeouts.lookup * 1000;
    var timeoutDownload = options.timeouts.download * 1000;
    var timeoutBuild = options.timeouts.build * 1000;

    registryInstance.versionString = registryInstance.versionString || versionString;

    var maxRetries = globalConfig.config.maxRetries || 3;

    // patch the calls to apply timeout and retry logic
    registryHooks.forEach(function(hook) {
      if (!registryInstance[hook])
        return;

      var runHook = registryInstance[hook];
      registryInstance[hook] = function() {
        var self = this;
        var args = arguments;
        var retries = 0;
        var timeout;
        if (hook == 'download')
          timeout = timeoutDownload;
        else if (hook == 'build')
          timeout = timeoutBuild;
        else
          timeout = timeoutLookup;

        return new Promise(function(resolve, reject) {

          function tryHook() {
            var active = true;

            var timer = setTimeout(function() {
              active = false;
              checkRetry();
            }, timeout);

            // in case registry is being reconfigured, chain on a promise
            // which delivers the registry to use, when it is ready
            (self.reconfigPromise_ || Promise.resolve(self))
            .then(function(endpoint) {
              self = endpoint;
              return runHook.apply(self, args);
            })
            .then(function(result) {
              clearTimeout(timer);
              if (active)
                resolve(result);
            }, function(err) {
              clearTimeout(timer);
              if (!active)
                return;
              active = false;
              return checkConfigure(err) || checkRetry(err);
            });
          }

<span class="apidocCodeCommentSpan">          /* When err.config is set, that indicates config credentials are somehow the cause.
           * Call the configure hook and reinstantiate the registry with new config */
</span>          function checkConfigure(err) {
            if (err &amp;&amp; err.config &amp;&amp; !self.triedConfig) {
              // Place promise chain on existing instance, to block subsequent hooks.
              // Also print warning for only for first such error, if multiple in a batch
              if (!self.reconfigPromise_) {
                ui.log('warn', err.message);

                self.reconfigPromise_ = exports.configure(registry)
                .then(function() {
                  // replace registered instance
                  delete registryClasses[registry];
                  var instance = exports.load(registry);
                  instance.triedConfig = true;
                  return instance;
                });
              }

              tryHook();
              return true;
            }
          }

          function checkRetry(err) {
            // don't retry build or processPackageConfig
            if (hook === 'build' || hook === 'p ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
break;

    case 'inspect':
options = readOptions(args, ['forks']);
args = options.args;

config.<span class="apidocCodeKeywordSpan">load</span>()
.then(function() {
  if (!args[1])
    return install.showVersions(options.forks);
  if (!args[1].includes(':'))
    return ui.log('warn', 'Enter a full package name of the format `registry:repo`.');
  return install.showInstallGraph(args[1]);
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.semver" id="apidoc.module.jspm.semver">module jspm.semver</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.semver.compare" id="apidoc.element.jspm.semver.compare">
        function <span class="apidocSignatureSpan">jspm.semver.</span>compare
        <span class="apidocSignatureSpan">(v1, v2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compare = function (v1, v2) {
  return semverCompareParsed(parseSemver(v1), parseSemver(v2));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
});

      // c. Forks against the existing tree are handled by upgrading the existing tree,
      //    at both primary and secondary levels, with the secondary fork potentially rolling back as well.
      resolveForks(installed, name, options.parent, resolution, function(forkVersion, forkRanges) {
if (options.latest &amp;&amp; semver.<span class="apidocCodeKeywordSpan">compare</span>(forkVersion, resolution.version) === 1
)
  return;

if (forkRanges.every(function(forkRange) {
  return semver.match(forkRange, resolution.version);
})) {
  consolidated = true;
  return resolution.version;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.semver.match" id="apidoc.element.jspm.semver.match">
        function <span class="apidocSignatureSpan">jspm.semver.</span>match
        <span class="apidocSignatureSpan">(range, version)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function match(range, version) {
  // supported range types:
  // 0.2, 1, ~1.2.3, ^1.2.3, ^0.4.3-alpha.1
  if (range === '' || range === '*')
    return true;
  return matchParsed(parseRange(range), parseSemver(version));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
})
.then(function() {
  logBuild(path.relative(process.cwd(), fileName), opts);
})
.catch(function(e) {
  // catch sfx globals error to give a better error message
  if (e.toString().indexOf('globalDeps option') != -1) {
    var module = e.toString().<span class="apidocCodeKeywordSpan">match</span>(/dependency "([^"]+)"/);
    ui.log('err', 'SFX exclusion "' + module[1] + '" needs a reference.\nEither output an SFX
 module format like %--format amd% or map the module to an environment global via %--globals "{\'test.js\': \'test\'}"%.');
    throw 'SFX Bundle input error';
  }

  ui.log('err', e.stack || e);
  throw e;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.semver.matchUnstable" id="apidoc.element.jspm.semver.matchUnstable">
        function <span class="apidocSignatureSpan">jspm.semver.</span>matchUnstable
        <span class="apidocSignatureSpan">(range, version)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function match(range, version) {
  // supported range types:
  // 0.2, 1, ~1.2.3, ^1.2.3, ^0.4.3-alpha.1
  if (range === '' || range === '*')
    return true;
  return matchParsed(parseRange(range), parseSemver(version), true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.ui" id="apidoc.module.jspm.ui">module jspm.ui</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.ui.confirm" id="apidoc.element.jspm.ui.confirm">
        function <span class="apidocSignatureSpan">jspm.ui.</span>confirm
        <span class="apidocSignatureSpan">(msg, def)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">confirm = function (msg, def) {
  if (useDefaults) {
    if (def !== true &amp;&amp; def !== false)
      def = true;
    process.stdout.write(format.q(msg) + (def ? 'Yes' : 'No') + '\n');
    return Promise.resolve(def);
  }

  if (apiResolver)
    return new Promise(function(resolve) {
      apiResolver.emit('prompt', {
        type: 'confirm',
        message: msg,
        default: def
      }, function(answer) {
        resolve(answer);
      });
    });

  var defText = 'y/n';
  if (def === true)
    defText = 'yes';
  else if (def === false)
    defText = 'no';
  else
    def = undefined;

  var p = cli.input(msg, defText);
  return p.then(function(reply) {
    if (reply.match(/\b(no|n)\b/i))
      return false;
    else if (reply.match(/\b(yes|y\b)/i))
      return true;
    else if (def !== undefined)
      return def;
    else
      return confirm(msg, def);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return (loadPromise = Promise.resolve()
.then(function() {

  if (process.env.globalJspm === 'true')
    ui.log('warn', 'Running jspm globally, it is advisable to locally install jspm via %npm install jspm --save-dev
%.');

  if (!process.env.jspmConfigPath)
    return ui.<span class="apidocCodeKeywordSpan">confirm</span>('Package.json file does not exist, create it?', true)
    .then(function(create) {
      if (!create)
        throw 'Operation aborted.';
    });
})
.then(function() {
  config.pjsonPath = process.env.jspmConfigPath || path.resolve(process.cwd(), 'package.json');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.ui.input" id="apidoc.element.jspm.ui.input">
        function <span class="apidocSignatureSpan">jspm.ui.</span>input
        <span class="apidocSignatureSpan">(msg, def, disableOutput, queue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">input = function (msg, def, disableOutput, queue) {
  if (useDefaults) {
    process.stdout.write(format.q(msg) + def + '\n');
    return Promise.resolve(def);
  }

  if (apiResolver)
    return new Promise(function(resolve) {
      apiResolver.emit('prompt', {
        type: 'input',
        message: msg,
        default: def
      }, function(answer) {
        resolve(answer.input);
      });
    });

  if (arguments.length === 2)
    disableOutput = false;

  return new Promise(function(resolve, reject) {
    if (!logging &amp;&amp; !queue)
      return inputQueue.push({
        args: [msg, def, disableOutput, true],
        resolve: resolve,
        reject: reject
      });

    if (logging &amp;&amp; logged)
      process.stdout.write('\n');
    logging = false;
    process.stdout.write(format.q(msg, def));
    process.stdin.resume();
    process.stdin.setEncoding('utf8');
    if (disableOutput &amp;&amp; process.stdin.isTTY)
      process.stdin.setRawMode(disableOutput);
    var inputVal = '';
    process.stdin.on('data', function(chunk) {
      var lastChar = chunk.substr(chunk.length - 1, 1);
      if (lastChar === '\n' || lastChar === '\r' || lastChar === '\u0004') {
        if (disableOutput &amp;&amp; process.stdin.isTTY)
          process.stdin.setRawMode(false);
        process.stdin.pause();
        process.stdin.removeAllListeners('data');
        inputVal += chunk.substr(0, chunk.length - 1);

        if (disableOutput)
          process.stdout.write('\n');

        // bump the input queue
        var next = inputQueue.shift();
        if (next)
          cli.input.apply(null, next.args).then(next.resolve, next.reject);
        else {
          process.stdout.write(logBuffer);
          process.stderr.write(errBuffer);
          logBuffer = '';
          errBuffer = '';
          logging = true;
          logged = false;
        }

        resolve(inputVal.trim() || def);
      }
      inputVal += chunk;
    });

  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (config.map &amp;&amp; hasProperties(config.map)) {

    var depMap;

    return Promise.resolve()
    .then(function() {
      if (!config.name)
        return ui.<span class="apidocCodeKeywordSpan">input</span>('Enter project name to use contextual mappings', &amp;#
x27;app')
        .then(function(name) {
config.name = name;

// if the lib directory is not in package.json, and we've given a name
// then the new lib default is the name not 'lib'
if (!pjsonCache.directories || !pjsonCache.directories.lib)
  config.lib = path.resolve(config.dir, config.name);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.ui.log" id="apidoc.element.jspm.ui.log">
        function <span class="apidocSignatureSpan">jspm.ui.</span>log
        <span class="apidocSignatureSpan">(type, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function (type, msg) {
  if (apiResolver)
    return apiResolver.emit('log', type, msg);

  logged = true;

  if (arguments.length === 1) {
    msg = type;
    type = null;
  }

  msg = msg || '';

  if (type)
    msg = format[type](msg.toString());

  var logLevel = logTypes.indexOf(type);
  if (logLevel == -1)
    logLevel = 3;
  if (logLevel &lt;= ui.logLevel) {
    if (logging) {
      if (type != 'err')
        console.log(msg);
      else
        console.error(msg);
    }
    else {
      if (type != 'err')
        logBuffer += msg + '\n';
      else
        errBuffer += msg + '\n';
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Promise = require('rsvp').Promise;

var link = require('./lib/link');

var build = require('./lib/build');

require('rsvp').on('error', function(reason) {
  ui.<span class="apidocCodeKeywordSpan">log</span>('warn', 'Unhandled promise rejection.\n' + reason &amp;&amp;#
x26; reason.stack || reason || '' + '\n');
});

process.on('uncaughtException', function(err) {
  ui.log('err', err.stack || err);
});

/* jshint laxbreak: true */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.ui.setLogLevel" id="apidoc.element.jspm.ui.setLogLevel">
        function <span class="apidocSignatureSpan">jspm.ui.</span>setLogLevel
        <span class="apidocSignatureSpan">(level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setLogLevel = function (level) {
  if (!level)
    return;

  var levelIndex = logTypes.indexOf(level);

  if (levelIndex == -1)
    ui.log('warn', 'Unknown log level: ' + level);
  else
    ui.logLevel = levelIndex;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// [].concat() to avoid mutating the given process.argv
var args = process.argv.slice(2),
    options;

var logArgIndex = args.indexOf('--log');
if (logArgIndex &gt; -1) {
  ui.<span class="apidocCodeKeywordSpan">setLogLevel</span>(args[logArgIndex + 1]);
  args.splice(logArgIndex, 2);
}

var cwdArgIndex = args.indexOf('--cwd');
if (cwdArgIndex &gt; -1) {
  args.splice(cwdArgIndex, 2);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.ui.setResolver" id="apidoc.element.jspm.ui.setResolver">
        function <span class="apidocSignatureSpan">jspm.ui.</span>setResolver
        <span class="apidocSignatureSpan">(resolver)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setResolver = function (resolver) {
  apiResolver = resolver;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jspm.ui.useDefaults" id="apidoc.element.jspm.ui.useDefaults">
        function <span class="apidocSignatureSpan">jspm.ui.</span>useDefaults
        <span class="apidocSignatureSpan">(_useDefaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">useDefaults = function (_useDefaults) {
  if (_useDefaults === undefined)
    _useDefaults = true;
  useDefaults = _useDefaults;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  else {
    options.override = eval('(' + override + ')');
  }
}

if (options.yes)
  ui.<span class="apidocCodeKeywordSpan">useDefaults</span>();

// jspm install with no arguments is locked
if (!depMap &amp;&amp; !doUpdate)
  options.lock = true;

// no install package -&gt; install from package.json dependencies
(depMap ? install.install(depMap, options) : install.install(true, options))
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jspm.utils" id="apidoc.module.jspm.utils">module jspm.utils</a></h1>


    <h2>
        <a href="#apidoc.element.jspm.utils.extractObj" id="apidoc.element.jspm.utils.extractObj">
        function <span class="apidocSignatureSpan">jspm.utils.</span>extractObj
        <span class="apidocSignatureSpan">(obj, host)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractObj(obj, host) {
  var out = {};
  for (var p in obj) {
    if (!obj.hasOwnProperty(p))
      continue;
    if (p.startsWith('__'))
      continue;

    var val = obj[p];
    if (typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean')
      out[p] = val;
    else if (typeof val === 'object') {
      if (typeof val.write === 'function')
        out[p] = val.write();
      else if (val instanceof Array)
        out[p] = val;
      else
        out[p] = extractObj(val, {});
    }
  }

  for (var h in host)
    if (host.hasOwnProperty(h) &amp;&amp; !(h in out))
      out[h] = host[h];

  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>